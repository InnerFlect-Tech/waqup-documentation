<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="waQup State Machine Documentation">
    <title>State Machine - waQup Documentation</title>
    <script type="module">
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'base',
            themeVariables: {
                primaryColor: '#2563eb',
                primaryTextColor: '#ffffff',
                primaryBorderColor: 'transparent',
                lineColor: '#475569',
                secondaryColor: '#f8fafc',
                tertiaryColor: '#f1f5f9',
                background: '#ffffff',
                mainBkg: '#ffffff',
                textColor: '#1e293b',
                border1: 'transparent',
                border2: 'transparent',
                noteBkgColor: '#fef3c7',
                noteTextColor: '#78350f',
                noteBorderColor: '#f59e0b',
                actorBorder: 'transparent',
                actorBkg: '#dbeafe',
                actorTextColor: '#1e293b',
                actorLineColor: '#475569',
                signalColor: '#1e293b',
                signalTextColor: '#1e293b',
                labelBoxBkgColor: '#dbeafe',
                labelBoxBorderColor: 'transparent',
                labelTextColor: '#1e293b',
                loopTextColor: '#1e293b',
                activationBorderColor: 'transparent',
                activationBkgColor: '#dbeafe',
                sequenceNumberColor: '#ffffff',
                sectionBkgColor: '#f8fafc',
                altSectionBkgColor: '#f1f5f9',
                sectionBkgColor2: '#e2e8f0',
                excludeBkgColor: '#fee2e2',
                excludeBorderColor: 'transparent',
                critBorderColor: 'transparent',
                critBkgColor: '#fee2e2',
                doneBkgColor: '#dbeafe',
                doneBorderColor: 'transparent',
                taskBorderColor: 'transparent',
                taskBkgColor: '#dbeafe',
                taskTextLightColor: '#ffffff',
                taskTextColor: '#1e293b',
                taskTextDarkColor: '#1e293b',
                taskTextOutsideColor: '#475569',
                taskTextClickableColor: '#2563eb',
                activeTaskBorderColor: 'transparent',
                activeTaskBkgColor: '#bfdbfe',
                gridColor: '#e2e8f0',
                doneTaskBkgColor: '#dbeafe',
                doneTaskBorderColor: 'transparent',
                critBorderColor: 'transparent',
                critBkgColor: '#fee2e2',
                todayLineColor: '#dc2626',
                labelColor: '#1e293b',
                errorBkgColor: '#fee2e2',
                errorTextColor: '#991b1b'
            },
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis',
                padding: 20
            },
            sequence: {
                diagramMarginX: 50,
                diagramMarginY: 10,
                actorMargin: 50,
                width: 150,
                height: 65,
                boxMargin: 10,
                boxTextMargin: 5,
                noteMargin: 10,
                messageMargin: 35,
                mirrorActors: true,
                bottomMarginAdj: 1,
                useMaxWidth: true,
                rightAngles: false,
                showSequenceNumbers: false
            },
            gantt: {
                titleTopMargin: 25,
                barHeight: 20,
                barGap: 4,
                topPadding: 50,
                leftPadding: 75,
                gridLineStartPadding: 35,
                fontSize: 11,
                fontFamily: 'inherit',
                numberSectionStyles: 4,
                axisFormat: '%Y-%m-%d',
                useMaxWidth: true
            }
        });
        
        // Remove borders from Mermaid diagrams after they render - ULTRA aggressive approach
        function removeMermaidBorders() {
            document.querySelectorAll('.mermaid svg').forEach(svg => {
                // Remove stroke from all rect, polygon, circle, and ellipse elements
                svg.querySelectorAll('rect, polygon, circle, ellipse').forEach(shape => {
                    // Skip if it's part of a path or line
                    const parent = shape.closest('g');
                    if (parent && (parent.classList.contains('edgePath') || parent.classList.contains('flowchart-link'))) {
                        return;
                    }
                    // Check if it's actually a shape (has fill) and not a line
                    const fill = shape.getAttribute('fill');
                    if (fill === 'none' || fill === 'transparent') {
                        // Might be a line, skip it
                        return;
                    }
                    // ULTRA aggressively remove stroke - ALL methods
                    shape.removeAttribute('stroke');
                    shape.setAttribute('stroke', 'none');
                    shape.setAttribute('stroke-width', '0');
                    shape.setAttribute('stroke-opacity', '0');
                    shape.style.stroke = 'none';
                    shape.style.strokeWidth = '0';
                    shape.style.strokeOpacity = '0';
                    shape.style.border = 'none';
                    // Force override with inline style
                    const currentStyle = shape.getAttribute('style') || '';
                    shape.setAttribute('style', currentStyle + ' stroke: none !important; stroke-width: 0 !important; stroke-opacity: 0 !important;');
                });
            });
        }
        
        // Run multiple times to catch all rendered diagrams
        function runBorderRemoval() {
            removeMermaidBorders();
            setTimeout(removeMermaidBorders, 100);
            setTimeout(removeMermaidBorders, 300);
            setTimeout(removeMermaidBorders, 500);
            setTimeout(removeMermaidBorders, 1000);
            setTimeout(removeMermaidBorders, 2000);
            setTimeout(removeMermaidBorders, 3000);
        }
        
        // Continuous border removal using requestAnimationFrame
        function continuousBorderRemoval() {
            removeMermaidBorders();
            requestAnimationFrame(continuousBorderRemoval);
        }
        
        // Start continuous removal after a short delay
        setTimeout(() => {
            // Run for 5 seconds continuously
            let count = 0;
            const interval = setInterval(() => {
                removeMermaidBorders();
                count++;
                if (count > 50) { // Stop after ~5 seconds (50 * 100ms)
                    clearInterval(interval);
                }
            }, 100);
        }, 500);
        
        // Run after Mermaid renders
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                runBorderRemoval();
            });
        } else {
            runBorderRemoval();
        }
        
        // Also use MutationObserver to catch dynamically rendered diagrams
        const observer = new MutationObserver((mutations) => {
            let shouldRun = false;
            mutations.forEach((mutation) => {
                if (mutation.addedNodes.length > 0) {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1 && (node.classList?.contains('mermaid') || node.querySelector?.('.mermaid'))) {
                            shouldRun = true;
                        }
                    });
                }
            });
            if (shouldRun) {
                removeMermaidBorders();
                setTimeout(removeMermaidBorders, 100);
                setTimeout(removeMermaidBorders, 500);
            }
        });
        
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['style', 'stroke', 'stroke-width']
        });
    </script>
        <link rel="stylesheet" href="../../styles.css">
        <script src="../../script.js"></script>
        <script src="../../navigation.js"></script>
    <script src="../../review-status.js"></script>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <!-- Sidebar generated by navigation.js -->
        </aside>
        <main class="main-content">
            <div class="content-wrapper">
                <a href="../index.html" class="back-link">Back to Conversational & Ritual System</a>
                
                <h1>State Machine</h1>
                <p class="lead">Complete state machine documentation with all states, transitions, and state definitions.</p>
                
                <hr>
                
                <h2 id="overview">Overview</h2>
                <p>The conversational system uses a state machine to manage user interactions during content creation. The state machine adapts its flow based on the selected content type (affirmation, guided meditation, or ritual).</p>
                
                <hr>
                
                <h2 id="complete-state-diagram">Complete State Diagram</h2>
                <div class="mermaid-container"><div class="mermaid">stateDiagram-v2
    [*] --> Idle: User opens app
    Idle --> TypeSelection: User clicks Create
    TypeSelection --> AffirmationFlow: Selects Affirmation
    TypeSelection --> MeditationFlow: Selects Meditation
    TypeSelection --> RitualFlow: Selects Ritual
    
    state AffirmationFlow {
        [*] --> Greeting
        Greeting --> IntentGathering: User responds
        IntentGathering --> StatementCollection: Intent received
        StatementCollection --> VoiceSelection: Statements complete
        VoiceSelection --> Review: Voice selected
        Review --> Confirmed: User confirms
        Review --> StatementCollection: User modifies
        Confirmed --> Generating
        Generating --> Complete
    }
    
    state MeditationFlow {
        [*] --> Greeting
        Greeting --> IntentGathering: User responds
        IntentGathering --> DurationSelection: Intent received
        DurationSelection --> PracticeTypeSelection: Duration selected
        PracticeTypeSelection --> ImageryGathering: Practice type selected
        ImageryGathering --> VoiceSelection: Imagery provided/skipped
        VoiceSelection --> Review: Voice selected
        Review --> Confirmed: User confirms
        Review --> DurationSelection: User modifies
        Confirmed --> Generating
        Generating --> Complete
    }
    
    state RitualFlow {
        [*] --> Greeting
        Greeting --> IntentGathering: User responds
        IntentGathering --> ContextGathering: Intent received
        ContextGathering --> DurationSelection: Context complete
        DurationSelection --> PracticeTypeSelection: Duration selected
        PracticeTypeSelection --> IdentityLanguageGathering: Practice type selected
        IdentityLanguageGathering --> EmotionalAnchoringGathering: Identity statements complete
        EmotionalAnchoringGathering --> VoiceSelection: Emotional goal provided
        VoiceSelection --> Review: Voice selected
        Review --> Confirmed: User confirms
        Review --> ContextGathering: User modifies
        Confirmed --> Generating
        Generating --> Complete
    }
    
    Complete --> Idle: Return to library
    Complete --> Practice: Start practice
    Practice --> Idle: Practice complete
                </div></div>
                
                <hr>
                
                <h2 id="state-definitions">State Definitions</h2>
                
                <h3 id="idle">Idle</h3>
                <p><strong>Description:</strong> Initial state when user opens the app or returns to the main interface.</p>
                <p><strong>Actions:</strong> None</p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>user_clicks_create</code> → <code>TypeSelection</code></li>
</ul>
                
                <h3 id="type-selection">TypeSelection</h3>
                <p><strong>Description:</strong> User selects which content type to create (affirmation, guided meditation, or ritual).</p>
                <p><strong>Actions:</strong> Display three options with brief explanations</p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>selects_affirmation</code> → <code>AffirmationFlow.Greeting</code></li>
                    <li><code>selects_meditation</code> → <code>MeditationFlow.Greeting</code></li>
                    <li><code>selects_ritual</code> → <code>RitualFlow.Greeting</code></li>
</ul>
                
                <h3 id="greeting">Greeting</h3>
                <p><strong>Description:</strong> System greets user and explains the creation process. Content varies based on selected type.</p>
                <p><strong>Actions:</strong> Send greeting message, explain process</p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>user_responds</code> → <code>IntentGathering</code></li>
</ul>
                
                <h3 id="intent-gathering">IntentGathering</h3>
                <p><strong>Description:</strong> System asks what the user wants to create. Question adapts to content type.</p>
                <p><strong>Questions Asked:</strong></p>
                <ul>
                    <li><strong>Affirmations:</strong> "What do you want to affirm or strengthen?"</li>
                    <li><strong>Meditations:</strong> "What state would you like to access?"</li>
                    <li><strong>Rituals:</strong> "What is changing in your life right now?"</li>
</ul>
                <p><strong>Data Saved:</strong> <code>intent: string</code></p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>intent_received</code> → Next state (varies by type)</li>
</ul>
                
                <h3 id="context-gathering">ContextGathering</h3>
                <p><strong>Description:</strong> <strong>Rituals only.</strong> System asks why this change matters and what the deeper meaning is.</p>
                <p><strong>Questions Asked:</strong></p>
                <ul>
                    <li>"Why does this matter to you?"</li>
                    <li>"What's the deeper meaning or significance?"</li>
</ul>
                <p><strong>Data Saved:</strong> <code>context: jsonb</code> {<code>why_matters: string</code>, <code>deeper_meaning: string</code>, <code>life_moment: string</code>}</p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>context_complete</code> → <code>DurationSelection</code></li>
</ul>
                
                <h3 id="statement-collection">StatementCollection</h3>
                <p><strong>Description:</strong> <strong>Affirmations only.</strong> System asks for 3-7 specific affirmation statements.</p>
                <p><strong>Questions Asked:</strong></p>
                <ul>
                    <li>"What specific statements feel true for you? Share 3-7 statements in present tense."</li>
</ul>
                <p><strong>Data Saved:</strong> <code>statements: string[]</code></p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>statements_complete</code> → <code>VoiceSelection</code></li>
</ul>
                
                <h3 id="duration-selection">DurationSelection</h3>
                <p><strong>Description:</strong> <strong>Meditations and Rituals only.</strong> System asks for preferred duration.</p>
                <p><strong>Questions Asked:</strong></p>
                <ul>
                    <li><strong>Meditations:</strong> "How long would you like this meditation? (5-20 minutes)"</li>
                    <li><strong>Rituals:</strong> "How long would you like this ritual? (10-30 minutes)"</li>
</ul>
                <p><strong>Data Saved:</strong> <code>duration_preference: integer</code></p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>duration_selected</code> → <code>PracticeTypeSelection</code></li>
</ul>
                
                <h3 id="practice-type-selection">PracticeTypeSelection</h3>
                <p><strong>Description:</strong> <strong>Meditations and Rituals only.</strong> System asks what practice type to include.</p>
                <p><strong>Questions Asked:</strong></p>
                <ul>
                    <li>"What practice type? Breath work, body scanning, visualization, or combination?"</li>
</ul>
                <p><strong>Data Saved:</strong> <code>practice_type: 'breath-work' | 'body-scanning' | 'visualization' | 'combination'</code></p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>practice_type_selected</code> → Next state (varies by type)</li>
</ul>
                
                <h3 id="imagery-gathering">ImageryGathering</h3>
                <p><strong>Description:</strong> <strong>Meditations only.</strong> System asks for specific imagery or visualization preferences.</p>
                <p><strong>Questions Asked:</strong></p>
                <ul>
                    <li>"Any specific imagery or visualization you'd like included?"</li>
</ul>
                <p><strong>Data Saved:</strong> <code>imagery: string | null</code></p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>imagery_provided_or_skipped</code> → <code>VoiceSelection</code></li>
</ul>
                
                <h3 id="identity-language-gathering">IdentityLanguageGathering</h3>
                <p><strong>Description:</strong> <strong>Rituals only.</strong> System asks for identity-level language that resonates.</p>
                <p><strong>Questions Asked:</strong></p>
                <ul>
                    <li>"What identity-level language resonates with you? How do you want to speak to yourself?"</li>
</ul>
                <p><strong>Data Saved:</strong> <code>identity_statements: string[]</code></p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>identity_statements_complete</code> → <code>EmotionalAnchoringGathering</code></li>
</ul>
                
                <h3 id="emotional-anchoring-gathering">EmotionalAnchoringGathering</h3>
                <p><strong>Description:</strong> <strong>Rituals only.</strong> System asks what emotional state to anchor.</p>
                <p><strong>Questions Asked:</strong></p>
<ul>
                    <li>"What emotional state do you want to anchor? What do you want to feel?"</li>
</ul>
                <p><strong>Data Saved:</strong> <code>emotional_goal: string</code></p>
                <p><strong>Transitions:</strong></p>
<ul>
                    <li><code>emotional_goal_provided</code> → <code>VoiceSelection</code></li>
</ul>
                
                <h3 id="voice-selection">VoiceSelection</h3>
                <p><strong>Description:</strong> System asks for voice preference. Available options vary by content type.</p>
                <p><strong>Questions Asked:</strong></p>
<ul>
                    <li>"Would you like to use your voice or a selected voice?"</li>
</ul>
                <p><strong>Data Saved:</strong> <code>voice_id: uuid</code>, <code>voice_type: 'user' | 'standard' | 'premium'</code></p>
                <p><strong>Transitions:</strong></p>
<ul>
                    <li><code>voice_selected</code> → <code>Review</code></li>
</ul>
                
                <h3 id="review">Review</h3>
                <p><strong>Description:</strong> System presents complete summary of all gathered information for user confirmation.</p>
                <p><strong>Actions:</strong> Display summary with all collected data</p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>user_confirms</code> → <code>Confirmed</code></li>
                    <li><code>user_modifies</code> → Returns to appropriate earlier state</li>
</ul>
                
                <h3 id="confirmed">Confirmed</h3>
                <p><strong>Description:</strong> User has confirmed all details. System prepares for generation.</p>
                <p><strong>Actions:</strong> Validate all required data, check credit availability</p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>ready_to_generate</code> → <code>Generating</code></li>
                    <li><code>insufficient_credits</code> → Show credit purchase prompt</li>
</ul>
                
                <h3 id="generating">Generating</h3>
                <p><strong>Description:</strong> System generates content text (LLM) and audio (TTS). Background process.</p>
                <p><strong>Actions:</strong> Call LLM with all context, generate text, synthesize audio, consume credit</p>
                <p><strong>Data Saved:</strong> <code>content_text: text</code>, <code>structure: jsonb</code>, <code>audio_url: string</code>, <code>audio_duration: integer</code>, <code>content_type: enum</code></p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>generation_complete</code> → <code>Complete</code></li>
                    <li><code>generation_failed</code> → Show error, return to <code>Review</code></li>
</ul>
                
                <h3 id="complete">Complete</h3>
                <p><strong>Description:</strong> Content is generated and saved. User can practice immediately or return to library.</p>
                <p><strong>Actions:</strong> Display success message, show "Practice Now" and "Save for Later" options</p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>practice_now</code> → <code>Practice</code></li>
                    <li><code>save_for_later</code> → <code>Idle</code></li>
</ul>
                
                <h3 id="practice">Practice</h3>
                <p><strong>Description:</strong> User is practicing the created content. Audio playback state.</p>
                <p><strong>Actions:</strong> Play audio, allow pause/resume, track playback position</p>
                <p><strong>Transitions:</strong></p>
                <ul>
                    <li><code>practice_complete</code> → <code>Idle</code> (save <code>last_played_at</code>, increment <code>play_count</code>)</li>
                    <li><code>pause</code> → <code>Practice</code> (paused state)</li>
                    <li><code>resume</code> → <code>Practice</code> (playing state)</li>
</ul>
                
                <hr>
                
                <h2 id="state-context">State Context</h2>
                <p>Each state maintains context about the conversation:</p>
                <ul>
                    <li><code>content_type: 'affirmation' | 'guided_meditation' | 'ritual'</code></li>
                    <li><code>intent: string</code></li>
                    <li><code>context: jsonb</code> (rituals only)</li>
                    <li><code>statements: string[]</code> (affirmations only)</li>
                    <li><code>duration_preference: integer</code> (meditations and rituals)</li>
                    <li><code>practice_type: string</code> (meditations and rituals)</li>
                    <li><code>imagery: string | null</code> (meditations only)</li>
                    <li><code>identity_statements: string[]</code> (rituals only)</li>
                    <li><code>emotional_goal: string</code> (rituals only)</li>
                    <li><code>voice_id: uuid</code></li>
                    <li><code>voice_type: string</code></li>
</ul>
                
                <hr>
                
                <h2 id="error-handling">Error Handling</h2>
                <p><strong>Credit Insufficient:</strong> If user doesn't have enough credits, system shows credit purchase prompt and remains in <code>Confirmed</code> state.</p>
                <p><strong>Generation Failure:</strong> If generation fails, system returns to <code>Review</code> state with error message, allowing user to modify and retry.</p>
                <p><strong>Network Error:</strong> System retries up to 3 times, then shows error and returns to <code>Review</code> state.</p>
                
                <hr>
                
                <h2 id="type-specific-flows">Type-Specific Flows</h2>
                
                <h3 id="affirmation-flow">Affirmation Flow</h3>
                <p><strong>States:</strong> Greeting → IntentGathering → StatementCollection → VoiceSelection → Review → Confirmed → Generating → Complete</p>
                <p><strong>Key Difference:</strong> No duration or practice type selection. Focuses on statements and voice.</p>
                
                <h3 id="meditation-flow">Meditation Flow</h3>
                <p><strong>States:</strong> Greeting → IntentGathering → DurationSelection → PracticeTypeSelection → ImageryGathering → VoiceSelection → Review → Confirmed → Generating → Complete</p>
                <p><strong>Key Difference:</strong> Includes duration, practice type, and optional imagery. No context or identity language gathering.</p>
                
                <h3 id="ritual-flow">Ritual Flow</h3>
                <p><strong>States:</strong> Greeting → IntentGathering → ContextGathering → DurationSelection → PracticeTypeSelection → IdentityLanguageGathering → EmotionalAnchoringGathering → VoiceSelection → Review → Confirmed → Generating → Complete</p>
                <p><strong>Key Difference:</strong> Most comprehensive flow. Includes context, identity language, and emotional anchoring—unique to rituals.</p>
            </div>
        </main>
    </div>
</body>
</html>
