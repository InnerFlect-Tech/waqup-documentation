<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="waQup - Voice-first ritual creation platform documentation">
    <title>Scientific Foundations</title>
    <script type="module">
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'base',
            themeVariables: {
                primaryColor: '#2563eb',
                primaryTextColor: '#ffffff',
                primaryBorderColor: 'transparent',
                lineColor: '#475569',
                secondaryColor: '#f8fafc',
                tertiaryColor: '#f1f5f9',
                background: '#ffffff',
                mainBkg: '#ffffff',
                textColor: '#1e293b',
                border1: 'transparent',
                border2: 'transparent',
                noteBkgColor: '#fef3c7',
                noteTextColor: '#78350f',
                noteBorderColor: '#f59e0b',
                actorBorder: 'transparent',
                actorBkg: '#dbeafe',
                actorTextColor: '#1e293b',
                actorLineColor: '#475569',
                signalColor: '#1e293b',
                signalTextColor: '#1e293b',
                labelBoxBkgColor: '#dbeafe',
                labelBoxBorderColor: 'transparent',
                labelTextColor: '#1e293b',
                loopTextColor: '#1e293b',
                activationBorderColor: 'transparent',
                activationBkgColor: '#dbeafe',
                sequenceNumberColor: '#ffffff',
                sectionBkgColor: '#f8fafc',
                altSectionBkgColor: '#f1f5f9',
                sectionBkgColor2: '#e2e8f0',
                excludeBkgColor: '#fee2e2',
                excludeBorderColor: 'transparent',
                critBorderColor: 'transparent',
                critBkgColor: '#fee2e2',
                doneBkgColor: '#dbeafe',
                doneBorderColor: 'transparent',
                taskBorderColor: 'transparent',
                taskBkgColor: '#dbeafe',
                taskTextLightColor: '#ffffff',
                taskTextColor: '#1e293b',
                taskTextDarkColor: '#1e293b',
                taskTextOutsideColor: '#475569',
                taskTextClickableColor: '#2563eb',
                activeTaskBorderColor: 'transparent',
                activeTaskBkgColor: '#bfdbfe',
                gridColor: '#e2e8f0',
                doneTaskBkgColor: '#dbeafe',
                doneTaskBorderColor: 'transparent',
                critBorderColor: 'transparent',
                critBkgColor: '#fee2e2',
                todayLineColor: '#dc2626',
                labelColor: '#1e293b',
                errorBkgColor: '#fee2e2',
                errorTextColor: '#991b1b'
            },
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis',
                padding: 20
            },
            sequence: {
                diagramMarginX: 50,
                diagramMarginY: 10,
                actorMargin: 50,
                width: 150,
                height: 65,
                boxMargin: 10,
                boxTextMargin: 5,
                noteMargin: 10,
                messageMargin: 35,
                mirrorActors: true,
                bottomMarginAdj: 1,
                useMaxWidth: true,
                rightAngles: false,
                showSequenceNumbers: false
            },
            gantt: {
                titleTopMargin: 25,
                barHeight: 20,
                barGap: 4,
                topPadding: 50,
                leftPadding: 75,
                gridLineStartPadding: 35,
                fontSize: 11,
                fontFamily: 'inherit',
                numberSectionStyles: 4,
                axisFormat: '%Y-%m-%d',
                useMaxWidth: true
            }
        });
        
        // Remove borders from Mermaid diagrams after they render - ULTRA aggressive approach
        function removeMermaidBorders() {
            document.querySelectorAll('.mermaid svg').forEach(svg => {
                // Remove stroke from all rect, polygon, circle, and ellipse elements
                svg.querySelectorAll('rect, polygon, circle, ellipse').forEach(shape => {
                    // Skip if it's part of a path or line
                    const parent = shape.closest('g');
                    if (parent && (parent.classList.contains('edgePath') || parent.classList.contains('flowchart-link'))) {
                        return;
                    }
                    // Check if it's actually a shape (has fill) and not a line
                    const fill = shape.getAttribute('fill');
                    if (fill === 'none' || fill === 'transparent') {
                        // Might be a line, skip it
                        return;
                    }
                    // ULTRA aggressively remove stroke - ALL methods
                    shape.removeAttribute('stroke');
                    shape.setAttribute('stroke', 'none');
                    shape.setAttribute('stroke-width', '0');
                    shape.setAttribute('stroke-opacity', '0');
                    shape.style.stroke = 'none';
                    shape.style.strokeWidth = '0';
                    shape.style.strokeOpacity = '0';
                    shape.style.border = 'none';
                    // Force override with inline style
                    const currentStyle = shape.getAttribute('style') || '';
                    shape.setAttribute('style', currentStyle + ' stroke: none !important; stroke-width: 0 !important; stroke-opacity: 0 !important;');
                });
            });
        }
        
        // Run multiple times to catch all rendered diagrams
        function runBorderRemoval() {
            removeMermaidBorders();
            setTimeout(removeMermaidBorders, 100);
            setTimeout(removeMermaidBorders, 300);
            setTimeout(removeMermaidBorders, 500);
            setTimeout(removeMermaidBorders, 1000);
            setTimeout(removeMermaidBorders, 2000);
            setTimeout(removeMermaidBorders, 3000);
        }
        
        // Continuous border removal using requestAnimationFrame
        function continuousBorderRemoval() {
            removeMermaidBorders();
            requestAnimationFrame(continuousBorderRemoval);
        }
        
        // Start continuous removal after a short delay
        setTimeout(() => {
            // Run for 5 seconds continuously
            let count = 0;
            const interval = setInterval(() => {
                removeMermaidBorders();
                count++;
                if (count > 50) { // Stop after ~5 seconds (50 * 100ms)
                    clearInterval(interval);
                }
            }, 100);
        }, 500);
        
        // Run after Mermaid renders
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                runBorderRemoval();
            });
        } else {
            runBorderRemoval();
        }
        
        // Also use MutationObserver to catch dynamically rendered diagrams
        const observer = new MutationObserver((mutations) => {
            let shouldRun = false;
            mutations.forEach((mutation) => {
                if (mutation.addedNodes.length > 0) {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1 && (node.classList?.contains('mermaid') || node.querySelector?.('.mermaid'))) {
                            shouldRun = true;
                        }
                    });
                }
            });
            if (shouldRun) {
                removeMermaidBorders();
                setTimeout(removeMermaidBorders, 100);
                setTimeout(removeMermaidBorders, 500);
            }
        });
        
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['style', 'stroke', 'stroke-width']
        });
    </script>
        <link rel="stylesheet" href="../../styles.css">
        <script src="../../script.js"></script>
        <script src="../../navigation.js"></script>
    <script src="../../review-status.js"></script>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <!-- Sidebar generated by navigation.js -->
        </aside>
        <main class="main-content">
            <div class="content-wrapper">
<a href="../index.html" class="back-link">Back to System Architecture</a>
                
                <h1>Core Architecture & APIs</h1>
                <p class="lead">Detailed system architecture, service definitions, API endpoints, and design principles.</p>
                
                <hr>
                
<h2 id="core-services-architecture">Core Services Architecture</h2>
<h3 id="conversation-service">Conversation Service</h3>
<p>Manages the state machine for ritual creation and return loops. Handles dialogue flow, context management, and user intent extraction.</p>
<strong>Key Responsibilities</strong>:
<ul>
<li>Maintain conversation state per user session</li>
<li>Route user inputs to appropriate handlers</li>
<li>Extract intent and context from natural language</li>
<li>Coordinate with Ritual Generation Service</li>
<li>Manage ephemeral vs. persistent conversation data</li>
</ul>
<h3 id="content-generation-service">Content Generation Service</h3>
<p>Generates personalized content (affirmations, guided meditations, rituals) using LLM based on user conversation and context.</p>
<strong>Key Responsibilities</strong>:
<ul>
<li>Validate credit availability before generation (via Credit Management Service)</li>
<li>Adapt generation logic based on content type (affirmation, meditation, ritual)</li>
<li>Call LLM with user intent, conversation history, and content type</li>
<li>Apply type-specific structure (affirmations: statements, meditations: state induction, rituals: identity encoding)</li>
<li>Apply personalization rules based on user profile and history</li>
<li>Structure content according to waQup format (type-specific)</li>
<li>Trigger audio generation after text generation</li>
<li>Consume credit on successful completion (cost varies by type)</li>
<li>Store generated content in database (with content_type)</li>
<li>Request credit refund on generation failure</li>
</ul>
<h3 id="audio-generation-service">Audio Generation Service</h3>
<p>Converts ritual text to audio using TTS, applies voice characteristics, and stores audio files.</p>
<strong>Key Responsibilities</strong>:
<ul>
<li>Call TTS API with ritual text and voice selection</li>
<li>Apply voice characteristics (pace, tone, pauses)</li>
<li>Store generated audio in object storage</li>
<li>Generate audio metadata (duration, format, quality)</li>
<li>Handle audio format conversion and optimization</li>
</ul>
<h3 id="ritual-library-service">Ritual Library Service</h3>
<p>Manages user's saved rituals, playback, and ritual history.</p>
<strong>Key Responsibilities</strong>:
<ul>
<li>Store and retrieve user's ritual library</li>
<li>Track playback history and practice frequency</li>
<li>Provide audio streaming URLs</li>
<li>Handle ritual sharing and export</li>
<li>Manage ritual organization (tags, folders)</li>
<li>Free unlimited replay (no credit consumption)</li>
</ul>
<h3 id="credit-management-service">Credit Management Service</h3>
<p>Manages user credit balances, consumption, and refunds.</p>
<strong>Key Responsibilities</strong>:
<ul>
<li>Track credit balance per user</li>
<li>Validate credit availability before consumption</li>
<li>Process credit consumption on successful ritual creation</li>
<li>Handle credit refunds on system errors</li>
<li>Record credit transaction history</li>
<li>Integrate with Payment Service for credit purchases</li>
<li>Provide credit balance API endpoints</li>
</ul>
                
                <hr>
                
<h2 id="api-flow">API Flow</h2>
<p>waQup uses a RESTful API architecture with WebSocket support for real-time conversation flows. All APIs are versioned, authenticated via JWT, and follow consistent patterns for error handling, rate limiting, and response formatting.</p>
<h2 id="api-gateway-flow">API Gateway Flow</h2>
<div class="mermaid-container"><div class="mermaid">sequenceDiagram
    participant Client
    participant API Gateway
    participant Auth Service
    participant Rate Limiter
    participant Service
    participant Database

    Client->>API Gateway: API Request + JWT Token
    API Gateway->>Auth Service: Validate Token
    Auth Service-->>API Gateway: Token Valid/Invalid
    alt Token Invalid
        API Gateway-->>Client: 401 Unauthorized
    else Token Valid
        API Gateway->>Rate Limiter: Check Rate Limit
        Rate Limiter-->>API Gateway: Limit OK/Exceeded
        alt Rate Limit Exceeded
            API Gateway-->>Client: 429 Too Many Requests
        else Rate Limit OK
            API Gateway->>Service: Route Request
            Service->>Database: Query/Update Data
            Database-->>Service: Return Data
            Service-->>API Gateway: Response
            API Gateway-->>Client: JSON Response
        end
    end</div></div>
<h2 id="core-api-endpoints">Core API Endpoints</h2>
<h3 id="authentication-apis">Authentication APIs</h3>
<strong>POST /api/v1/auth/register</strong>
<pre><code>Request:
<p>{</p>
<p>"email": "user@example.com",</p>
<p>"password": "securepassword"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"token": "jwt_token_here",</p>
<p>"refresh_token": "refresh_token_here",</p>
<p>"user": {</p>
<p>"id": "uuid",</p>
<p>"email": "user@example.com"</p>
<p>}</p>
<p>}</code></pre>
<strong>POST /api/v1/auth/login</strong>
<pre><code>Request:
<p>{</p>
<p>"email": "user@example.com",</p>
<p>"password": "securepassword"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"token": "jwt_token_here",</p>
<p>"refresh_token": "refresh_token_here",</p>
<p>"user": {</p>
<p>"id": "uuid",</p>
<p>"email": "user@example.com"</p>
<p>}</p>
<p>}</code></pre>
<strong>POST /api/v1/auth/refresh</strong>
<pre><code>Request:
<p>{</p>
<p>"refresh_token": "refresh_token_here"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"token": "new_jwt_token_here"</p>
<p>}</code></pre>
<h3 id="conversation-apis">Conversation APIs</h3>
<strong>WebSocket: /ws/conversation</strong>
<pre><code>// Connect
<p>ws://api.waqup.com/ws/conversation?token=jwt_token</p>
<p>// Send message</p>
<p>{</p>
<p>"type": "message",</p>
<p>"content": "I need something to help me sleep",</p>
<p>"session_id": "session_uuid"</p>
<p>}</p>
<p>// Receive response</p>
<p>{</p>
<p>"type": "response",</p>
<p>"content": "I'd be happy to help you create a ritual for sleep...",</p>
<p>"state": "IntentDiscovery",</p>
<p>"session_id": "session_uuid"</p>
<p>}</code></pre>
<strong>POST /api/v1/conversation/start</strong>
<pre><code>Request:
<p>{</p>
<p>"content_type": "affirmation" | "guided_meditation" | "ritual",</p>
<p>"intent": "sleep" // optional, can be discovered through conversation</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"session_id": "uuid",</p>
<p>"content_type": "ritual",</p>
<p>"state": "Greeting",</p>
<p>"message": "Hello! I'd be happy to help you create a personalized ritual..."</p>
<p>}</code></pre>
<strong>POST /api/v1/conversation/message</strong>
<pre><code>Request:
<p>{</p>
<p>"session_id": "uuid",</p>
<p>"message": "I want something calming for evening"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"session_id": "uuid",</p>
<p>"state": "ContextGathering",</p>
<p>"response": "That sounds wonderful. When would you like to practice this?",</p>
<p>"context": {</p>
<p>"intent": "calming",</p>
<p>"time_preference": null</p>
<p>}</p>
<p>}</code></pre>
<strong>GET /api/v1/conversation/state</strong>
<pre><code>Response:
<p>{</p>
<p>"session_id": "uuid",</p>
<p>"state": "PracticeDetails",</p>
<p>"context": {</p>
<p>"intent": "calming",</p>
<p>"time_preference": "evening",</p>
<p>"duration": "10 minutes"</p>
<p>},</p>
<p>"messages": [...]</p>
<p>}</code></pre>
<strong>POST /api/v1/conversation/complete</strong>
<pre><code>Request:
<p>{</p>
<p>"session_id": "uuid",</p>
<p>"confirm": true</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"ritual_id": "uuid",</p>
<p>"status": "generating",</p>
<p>"estimated_time": 30 // seconds</p>
<p>}</code></pre>
<h3 id="content-apis-affirmations-guided-meditations-rituals">Content APIs (Affirmations, Guided Meditations, Rituals)</h3>
<strong>GET /api/v1/content</strong>
<pre><code>Query Parameters:
<ul>
<li>content_type: "affirmation" | "guided_meditation" | "ritual" | null (all)</li>
<li>page: number (default: 1)</li>
<li>limit: number (default: 20)</li>
<li>tags: string[] (optional)</li>
<li>depth: "shallow" | "medium" | "deep" | null (all)</li>
</ul>
<p>Response:</p>
<p>{</p>
<p>"content_items": [</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"content_type": "ritual",</p>
<p>"title": "Evening Calm",</p>
<p>"depth": "deep",</p>
<p>"duration": 600,</p>
<p>"tags": ["evening", "calming"],</p>
<p>"created_at": "2024-01-01T00:00:00Z",</p>
<p>"last_played_at": "2024-01-15T10:30:00Z",</p>
<p>"play_count": 12</p>
<p>}</p>
<p>],</p>
<p>"pagination": {</p>
<p>"page": 1,</p>
<p>"limit": 20,</p>
<p>"total": 45,</p>
<p>"pages": 3</p>
<p>}</p>
<p>}</code></pre>
<strong>GET /api/v1/content/{id}</strong>
<pre><code>Response:
<p>{</p>
<p>"id": "uuid",</p>
<p>"content_type": "ritual",</p>
<p>"title": "Evening Calm",</p>
<p>"content_text": "Find a comfortable position...",</p>
<p>"depth": "deep",</p>
<p>"duration": 600,</p>
<p>"tags": ["calming", "evening", "breath"],</p>
<p>"voice": {</p>
<p>"id": "uuid",</p>
<p>"name": "Calm Guide"</p>
<p>},</p>
<p>"audio_url": "https://cdn.waqup.com/audio/...",</p>
<p>"created_at": "2024-01-01T00:00:00Z",</p>
<p>"structure": {...},</p>
<p>"context": {...}</p>
<p>}</code></pre>
<strong>POST /api/v1/content/{id}/play</strong>
<pre><code>Request:
<p>{</p>
<p>"started_at": "2024-01-15T10:30:00Z"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"practice_event_id": "uuid",</p>
<p>"status": "started"</p>
<p>}</code></pre>
<strong>POST /api/v1/content/{id}/complete</strong>
<pre><code>Request:
<p>{</p>
<p>"practice_event_id": "uuid",</p>
<p>"completed_at": "2024-01-15T10:40:00Z",</p>
<p>"duration": 600</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"practice_event_id": "uuid",</p>
<p>"status": "completed"</p>
<p>}</code></pre>
<strong>DELETE /api/v1/content/{id}</strong>
<pre><code>Response:
<p>{</p>
<p>"status": "deleted",</p>
<p>"content_item_id": "uuid"</p>
<p>}</code></pre>
<strong>GET /api/v1/content/{id}/export</strong>
<pre><code>Query Parameters:
<ul>
<li>format: "text" | "audio" | "both"</li>
</ul>
<p>Response:</p>
<p>{</p>
<p>"text": "Find a comfortable position...",</p>
<p>"audio_url": "https://cdn.waqup.com/audio/...",</p>
<p>"exported_at": "2024-01-15T10:45:00Z"</p>
<p>}</code></pre>
<h3 id="marketplace-apis">Marketplace APIs</h3>
<strong>GET /api/v1/catalog/packs</strong>
<pre><code>Query Parameters:
<ul>
<li>page: number</li>
<li>limit: number</li>
<li>search: string</li>
<li>tags: string[]</li>
<li>creator_id: uuid</li>
<li>price_type: "free" | "one_time" | "subscription"</li>
</ul>
<p>Response:</p>
<p>{</p>
<p>"packs": [</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"title": "Morning Energy Pack",</p>
<p>"description": "Start your day with intention...",</p>
<p>"creator": {</p>
<p>"id": "uuid",</p>
<p>"name": "Sarah Facilitator"</p>
<p>},</p>
<p>"price_type": "subscription",</p>
<p>"price_amount": 9.99,</p>
<p>"subscription_interval": "monthly",</p>
<p>"ritual_count": 5,</p>
<p>"rating": 4.8,</p>
<p>"review_count": 127</p>
<p>}</p>
<p>],</p>
<p>"pagination": {...}</p>
<p>}</code></pre>
<strong>GET /api/v1/catalog/packs/{id}</strong>
<pre><code>Response:
<p>{</p>
<p>"id": "uuid",</p>
<p>"title": "Morning Energy Pack",</p>
<p>"description": "Start your day with intention...",</p>
<p>"creator": {...},</p>
<p>"rituals": [</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"title": "Sunrise Breath",</p>
<p>"duration": 300,</p>
<p>"practice_type": "breath_work"</p>
<p>}</p>
<p>],</p>
<p>"price_type": "subscription",</p>
<p>"price_amount": 9.99,</p>
<p>"user_has_access": false</p>
<p>}</code></pre>
<strong>GET /api/v1/catalog/recommendations</strong>
<pre><code>Response:
<p>{</p>
<p>"recommendations": [</p>
<p>{</p>
<p>"pack_id": "uuid",</p>
<p>"reason": "Based on your practice history",</p>
<p>"score": 0.85</p>
<p>}</p>
<p>]</p>
<p>}</code></pre>
<strong>POST /api/v1/payments/checkout</strong>
<pre><code>Request:
<p>{</p>
<p>"pack_id": "uuid",</p>
<p>"price_type": "subscription",</p>
<p>"success_url": "https://app.waqup.com/success",</p>
<p>"cancel_url": "https://app.waqup.com/cancel"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"checkout_url": "https://checkout.stripe.com/...",</p>
<p>"session_id": "stripe_session_id"</p>
<p>}</code></pre>
<strong>POST /api/v1/payments/webhook</strong>
<pre><code>// Stripe webhook handler (internal)
<p>Request:</p>
<p>{</p>
<p>"type": "checkout.session.completed",</p>
<p>"data": {</p>
<p>"object": {</p>
<p>"id": "stripe_session_id",</p>
<p>"metadata": {</p>
<p>"pack_id": "uuid",</p>
<p>"user_id": "uuid"</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</code></pre>
<h3 id="user-apis">User APIs</h3>
<strong>GET /api/v1/users/me</strong>
<pre><code>Response:
<p>{</p>
<p>"id": "uuid",</p>
<p>"email": "user@example.com",</p>
<p>"preferences": {</p>
<p>"voice_id": "uuid",</p>
<p>"pace": "moderate",</p>
<p>"tone": "warm"</p>
<p>},</p>
<p>"created_at": "2024-01-01T00:00:00Z"</p>
<p>}</code></pre>
<strong>PUT /api/v1/users/me</strong>
<pre><code>Request:
<p>{</p>
<p>"preferences": {</p>
<p>"voice_id": "new_voice_id",</p>
<p>"pace": "slower"</p>
<p>}</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"preferences": {</p>
<p>"voice_id": "new_voice_id",</p>
<p>"pace": "slower",</p>
<p>"tone": "warm"</p>
<p>}</p>
<p>}</code></pre>
<strong>GET /api/v1/users/me/history</strong>
<pre><code>Query Parameters:
<ul>
<li>page: number</li>
<li>limit: number</li>
<li>ritual_id: uuid (optional)</li>
</ul>
<p>Response:</p>
<p>{</p>
<p>"practice_events": [</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"ritual_id": "uuid",</p>
<p>"ritual_title": "Evening Calm",</p>
<p>"started_at": "2024-01-15T10:30:00Z",</p>
<p>"completed_at": "2024-01-15T10:40:00Z",</p>
<p>"duration": 600</p>
<p>}</p>
<p>],</p>
<p>"pagination": {...}</p>
<p>}</code></pre>
<h3 id="credit-apis">Credit APIs</h3>
<strong>GET /api/v1/credits/balance</strong>
<pre><code>Response:
<p>{</p>
<p>"balance": 5,</p>
<p>"free_tier_used": true,</p>
<p>"last_transaction_at": "2024-01-15T10:30:00Z"</p>
<p>}</code></pre>
<strong>GET /api/v1/credits/transactions</strong>
<pre><code>Query Parameters:
<ul>
<li>page: number</li>
<li>limit: number</li>
<li>transaction_type: "purchase" | "consumption" | "refund" (optional)</li>
</ul>
<p>Response:</p>
<p>{</p>
<p>"transactions": [</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"type": "consumption",</p>
<p>"amount": -1,</p>
<p>"balance_after": 4,</p>
<p>"ritual_id": "uuid",</p>
<p>"created_at": "2024-01-15T10:30:00Z"</p>
<p>},</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"type": "purchase",</p>
<p>"amount": 10,</p>
<p>"balance_after": 11,</p>
<p>"pack_id": "seeker",</p>
<p>"created_at": "2024-01-10T08:00:00Z"</p>
<p>}</p>
<p>],</p>
<p>"pagination": {...}</p>
<p>}</code></pre>
<strong>POST /api/v1/credits/purchase</strong>
<pre><code>Request:
<p>{</p>
<p>"pack_type": "starter" | "seeker" | "architect",</p>
<p>"success_url": "https://app.waqup.com/success",</p>
<p>"cancel_url": "https://app.waqup.com/cancel"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"checkout_url": "https://checkout.stripe.com/...",</p>
<p>"session_id": "stripe_session_id",</p>
<p>"credits_amount": 3</p>
<p>}</code></pre>
<strong>POST /api/v1/credits/check</strong>
<pre><code>Request:
<p>{</p>
<p>"action": "ritual_creation",</p>
<p>"ritual_id": "uuid" // optional, for modifications</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"sufficient": true,</p>
<p>"balance": 5,</p>
<p>"required": 1,</p>
<p>"message": "You have sufficient credits"</p>
<p>}</code></pre>
<h2 id="api-flow-diagrams">API Flow Diagrams</h2>
<h3 id="ritual-creation-flow">Ritual Creation Flow</h3>
<div class="mermaid-container"><div class="mermaid">sequenceDiagram
    participant Client
    participant API Gateway
    participant Conversation Service
    participant Ritual Gen Service
    participant LLM
    participant Audio Gen Service
    participant TTS
    participant Database

    Client->>API Gateway: POST /conversation/start (with content_type)
    API Gateway->>Conversation Service: Create session
    Conversation Service->>Database: Store session state + content_type
    Conversation Service-->>Client: Session ID + Greeting (type-specific)

    Client->>API Gateway: POST /conversation/message
    API Gateway->>Conversation Service: Process message
    Conversation Service->>Database: Update session state
    Conversation Service-->>Client: Response + Next question

    Note over Client,Conversation Service: Repeat until ritual confirmed

    Client->>API Gateway: POST /conversation/complete
    API Gateway->>Conversation Service: Finalize ritual
    Conversation Service->>Credit Service: Check credit balance
    Credit Service-->>Conversation Service: Credit available
    Conversation Service->>Ritual Gen Service: Generate ritual
    Ritual Gen Service->>LLM: Generate text
    LLM-->>Ritual Gen Service: Ritual text
    Ritual Gen Service->>Database: Store ritual text
    Ritual Gen Service->>Audio Gen Service: Generate audio
    Audio Gen Service->>TTS: Synthesize voice
    TTS-->>Audio Gen Service: Audio file
    Audio Gen Service->>Database: Store audio URL
    Audio Gen Service->>Credit Service: Consume credit (on success)
    Credit Service-->>Audio Gen Service: Credit consumed
    Audio Gen Service-->>Ritual Gen Service: Audio ready
    Ritual Gen Service-->>Conversation Service: Ritual complete
    Conversation Service-->>Client: Ritual ID + Status</div></div>
<h3 id="ritual-playback-flow">Ritual Playback Flow</h3>
<div class="mermaid-container"><div class="mermaid">sequenceDiagram
    participant Client
    participant API Gateway
    participant Ritual Library Service
    participant Cache
    participant Database
    participant CDN

    Client->>API Gateway: GET /content/{id}
    API Gateway->>Ritual Library Service: Get content item
    Ritual Library Service->>Cache: Check cache
    alt Cache Hit
        Cache-->>Ritual Library Service: Cached data
    else Cache Miss
        Ritual Library Service->>Database: Query ritual
        Database-->>Ritual Library Service: Ritual data
        Ritual Library Service->>Cache: Store in cache
    end
    Ritual Library Service->>CDN: Generate pre-signed URL
    CDN-->>Ritual Library Service: Audio URL
    Ritual Library Service-->>Client: Ritual + Audio URL

    Client->>API Gateway: POST /content/{id}/play
    API Gateway->>Ritual Library Service: Record play event
    Ritual Library Service->>Database: Store practice event (with content_type)
    Ritual Library Service-->>Client: Practice started

    Client->>CDN: Stream audio
    CDN-->>Client: Audio stream

    Client->>API Gateway: POST /content/{id}/complete
    API Gateway->>Ritual Library Service: Complete practice
    Ritual Library Service->>Database: Update practice event
    Ritual Library Service-->>Client: Practice completed</div></div>
<h3 id="marketplace-purchase-flow">Marketplace Purchase Flow</h3>
<div class="mermaid-container"><div class="mermaid">sequenceDiagram
    participant Client
    participant API Gateway
    participant Catalog Service
    participant Payment Service
    participant Stripe
    participant Database
    participant Ritual Library Service

    Client->>API Gateway: GET /catalog/packs/{id}
    API Gateway->>Catalog Service: Get pack details
    Catalog Service->>Database: Query pack
    Database-->>Catalog Service: Pack data
    Catalog Service-->>Client: Pack details

    Client->>API Gateway: POST /payments/checkout
    API Gateway->>Payment Service: Create checkout
    Payment Service->>Stripe: Create checkout session
    Stripe-->>Payment Service: Checkout URL
    Payment Service-->>Client: Redirect to Stripe

    Client->>Stripe: Complete payment
    Stripe->>Payment Service: Webhook (payment success)
    Payment Service->>Database: Record purchase
    Payment Service->>Ritual Library Service: Grant access
    Ritual Library Service->>Database: Link pack to user
    Payment Service-->>Stripe: Webhook acknowledged

    Client->>API Gateway: GET /catalog/packs/{id}
    API Gateway->>Catalog Service: Get pack
    Catalog Service->>Database: Query pack + access
    Database-->>Catalog Service: Pack + user_has_access: true
    Catalog Service-->>Client: Pack with access granted</div></div>
<h2 id="api-design-principles">API Design Principles</h2>
<h3 id="restful-design">RESTful Design</h3>
<ul>
<li>Standard HTTP methods (GET, POST, PUT, DELETE)</li>
<li>Resource-based URLs (<code>/rituals/{id}</code>)</li>
<li>Consistent response formats</li>
<li>Proper HTTP status codes</li>
</ul>
<h3 id="versioning">Versioning</h3>
<ul>
<li>URL-based versioning (<code>/api/v1/...</code>)</li>
<li>Backward compatibility maintained</li>
<li>Deprecation notices for old versions</li>
</ul>
<h3 id="authentication">Authentication</h3>
<ul>
<li>JWT tokens for stateless auth</li>
<li>Refresh token rotation</li>
<li>Token expiration (15 minutes access, 7 days refresh)</li>
</ul>
<h3 id="rate-limiting">Rate Limiting</h3>
<ul>
<li>Per-user rate limits</li>
<li>Tiered limits (free vs. paid users)</li>
<li>429 status code with retry-after header</li>
</ul>
<h3 id="error-handling">Error Handling</h3>
<pre><code>{
<p>"error": {</p>
<p>"code": "RITUAL_NOT_FOUND",</p>
<p>"message": "Ritual with ID {id} not found",</p>
<p>"details": {...}</p>
<p>}</p>
<p>}</code></pre>
<h3 id="pagination">Pagination</h3>
<pre><code>{
<p>"data": [...],</p>
<p>"pagination": {</p>
<p>"page": 1,</p>
<p>"limit": 20,</p>
<p>"total": 100,</p>
<p>"pages": 5,</p>
<p>"has_next": true,</p>
<p>"has_prev": false</p>
<p>}</p>
<p>}</code></pre>
<h2 id="api-performance">API Performance</h2>
<h3 id="caching-strategy">Caching Strategy</h3>
<ul>
<li>Redis cache for frequently accessed data</li>
<li>Cache TTL: 15 minutes (user profiles), 1 hour (ritual metadata)</li>
<li>CDN cache for audio files (long TTL)</li>
</ul>
<h3 id="async-processing">Async Processing</h3>
<ul>
<li>Audio generation via message queue</li>
<li>LLM calls can be async for non-real-time flows</li>
<li>Webhook processing async</li>
</ul>
<h3 id="response-times">Response Times</h3>
<ul>
<li>API responses: < 200ms (p95)</li>
<li>Audio generation: < 30s (async)</li>
<li>Ritual generation: < 10s (LLM call)</li>
</ul>
<h2 id="api-security">API Security</h2>
<h3 id="input-validation">Input Validation</h3>
<ul>
<li>Schema validation for all requests</li>
<li>SQL injection prevention</li>
<li>XSS prevention</li>
<li>Rate limiting</li>
</ul>
<h3 id="data-protection">Data Protection</h3>
<ul>
<li>No sensitive data in URLs</li>
<li>Pre-signed URLs for audio (time-limited)</li>
<li>Encryption at rest and in transit</li>
<li>GDPR compliance</li>
</ul>
<h3 id="monitoring">Monitoring</h3>
<ul>
<li>Request logging (structured JSON)</li>
<li>Error tracking</li>
<li>Performance monitoring</li>
<li>Security event logging</li>
</ul>
            </div>
        </main>
    </div>
</body>
</html>
            </div>
            </div>
        </main>
    </div>
</body>
</html>