<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="waQup - Voice-first ritual creation platform documentation">
    <title>Scientific Foundations</title>
    <script type="module">
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'base',
            themeVariables: {
                primaryColor: '#2563eb',
                primaryTextColor: '#ffffff',
                primaryBorderColor: 'transparent',
                lineColor: '#475569',
                secondaryColor: '#f8fafc',
                tertiaryColor: '#f1f5f9',
                background: '#ffffff',
                mainBkg: '#ffffff',
                textColor: '#1e293b',
                border1: 'transparent',
                border2: 'transparent',
                noteBkgColor: '#fef3c7',
                noteTextColor: '#78350f',
                noteBorderColor: '#f59e0b',
                actorBorder: 'transparent',
                actorBkg: '#dbeafe',
                actorTextColor: '#1e293b',
                actorLineColor: '#475569',
                signalColor: '#1e293b',
                signalTextColor: '#1e293b',
                labelBoxBkgColor: '#dbeafe',
                labelBoxBorderColor: 'transparent',
                labelTextColor: '#1e293b',
                loopTextColor: '#1e293b',
                activationBorderColor: 'transparent',
                activationBkgColor: '#dbeafe',
                sequenceNumberColor: '#ffffff',
                sectionBkgColor: '#f8fafc',
                altSectionBkgColor: '#f1f5f9',
                sectionBkgColor2: '#e2e8f0',
                excludeBkgColor: '#fee2e2',
                excludeBorderColor: 'transparent',
                critBorderColor: 'transparent',
                critBkgColor: '#fee2e2',
                doneBkgColor: '#dbeafe',
                doneBorderColor: 'transparent',
                taskBorderColor: 'transparent',
                taskBkgColor: '#dbeafe',
                taskTextLightColor: '#ffffff',
                taskTextColor: '#1e293b',
                taskTextDarkColor: '#1e293b',
                taskTextOutsideColor: '#475569',
                taskTextClickableColor: '#2563eb',
                activeTaskBorderColor: 'transparent',
                activeTaskBkgColor: '#bfdbfe',
                gridColor: '#e2e8f0',
                doneTaskBkgColor: '#dbeafe',
                doneTaskBorderColor: 'transparent',
                critBorderColor: 'transparent',
                critBkgColor: '#fee2e2',
                todayLineColor: '#dc2626',
                labelColor: '#1e293b',
                errorBkgColor: '#fee2e2',
                errorTextColor: '#991b1b'
            },
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis',
                padding: 20
            },
            sequence: {
                diagramMarginX: 50,
                diagramMarginY: 10,
                actorMargin: 50,
                width: 150,
                height: 65,
                boxMargin: 10,
                boxTextMargin: 5,
                noteMargin: 10,
                messageMargin: 35,
                mirrorActors: true,
                bottomMarginAdj: 1,
                useMaxWidth: true,
                rightAngles: false,
                showSequenceNumbers: false
            },
            gantt: {
                titleTopMargin: 25,
                barHeight: 20,
                barGap: 4,
                topPadding: 50,
                leftPadding: 75,
                gridLineStartPadding: 35,
                fontSize: 11,
                fontFamily: 'inherit',
                numberSectionStyles: 4,
                axisFormat: '%Y-%m-%d',
                useMaxWidth: true
            }
        });
        
        // Remove borders from Mermaid diagrams after they render - ULTRA aggressive approach
        function removeMermaidBorders() {
            document.querySelectorAll('.mermaid svg').forEach(svg => {
                // Remove stroke from all rect, polygon, circle, and ellipse elements
                svg.querySelectorAll('rect, polygon, circle, ellipse').forEach(shape => {
                    // Skip if it's part of a path or line
                    const parent = shape.closest('g');
                    if (parent && (parent.classList.contains('edgePath') || parent.classList.contains('flowchart-link'))) {
                        return;
                    }
                    // Check if it's actually a shape (has fill) and not a line
                    const fill = shape.getAttribute('fill');
                    if (fill === 'none' || fill === 'transparent') {
                        // Might be a line, skip it
                        return;
                    }
                    // ULTRA aggressively remove stroke - ALL methods
                    shape.removeAttribute('stroke');
                    shape.setAttribute('stroke', 'none');
                    shape.setAttribute('stroke-width', '0');
                    shape.setAttribute('stroke-opacity', '0');
                    shape.style.stroke = 'none';
                    shape.style.strokeWidth = '0';
                    shape.style.strokeOpacity = '0';
                    shape.style.border = 'none';
                    // Force override with inline style
                    const currentStyle = shape.getAttribute('style') || '';
                    shape.setAttribute('style', currentStyle + ' stroke: none !important; stroke-width: 0 !important; stroke-opacity: 0 !important;');
                });
            });
        }
        
        // Run multiple times to catch all rendered diagrams
        function runBorderRemoval() {
            removeMermaidBorders();
            setTimeout(removeMermaidBorders, 100);
            setTimeout(removeMermaidBorders, 300);
            setTimeout(removeMermaidBorders, 500);
            setTimeout(removeMermaidBorders, 1000);
            setTimeout(removeMermaidBorders, 2000);
            setTimeout(removeMermaidBorders, 3000);
        }
        
        // Continuous border removal using requestAnimationFrame
        function continuousBorderRemoval() {
            removeMermaidBorders();
            requestAnimationFrame(continuousBorderRemoval);
        }
        
        // Start continuous removal after a short delay
        setTimeout(() => {
            // Run for 5 seconds continuously
            let count = 0;
            const interval = setInterval(() => {
                removeMermaidBorders();
                count++;
                if (count > 50) { // Stop after ~5 seconds (50 * 100ms)
                    clearInterval(interval);
                }
            }, 100);
        }, 500);
        
        // Run after Mermaid renders
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                runBorderRemoval();
            });
        } else {
            runBorderRemoval();
        }
        
        // Also use MutationObserver to catch dynamically rendered diagrams
        const observer = new MutationObserver((mutations) => {
            let shouldRun = false;
            mutations.forEach((mutation) => {
                if (mutation.addedNodes.length > 0) {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1 && (node.classList?.contains('mermaid') || node.querySelector?.('.mermaid'))) {
                            shouldRun = true;
                        }
                    });
                }
            });
            if (shouldRun) {
                removeMermaidBorders();
                setTimeout(removeMermaidBorders, 100);
                setTimeout(removeMermaidBorders, 500);
            }
        });
        
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['style', 'stroke', 'stroke-width']
        });
    </script>
        <link rel="stylesheet" href="../../styles.css">
        <script src="../../script.js"></script>
        <script src="../../navigation.js"></script>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <!-- Sidebar generated by navigation.js -->
        </aside>
        <main class="main-content">
            <div class="content-wrapper">
                <a href="../index.html" class="back-link">‚Üê Back to System Architecture</a>
                
                <h1>Security</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#architecture-overview">Architecture Overview</a></li>
<li><a href="#system-architecture">System Architecture</a></li>
<li><a href="#technology-stack">Technology Stack</a></li>
<li><a href="#core-services-architecture">Core Services Architecture</a></li>
<li><a href="#data-flow">Data Flow</a></li>
<li><a href="#api-flow">API Flow</a></li>
<li><a href="#data-architecture">Data Architecture</a></li>
<li><a href="#security-architecture">Security Architecture</a></li>
<li><a href="#scalability-strategy">Scalability Strategy</a></li>
<li><a href="#deployment-architecture">Deployment Architecture</a></li>
<li><a href="#observability">Observability</a></li>
</ul>
<hr>
<h2 id="architecture-overview">Architecture Overview</h2>
<p>> This section covers the high-level system architecture. For detailed data flows, see <a href="#data-flow">Data Flow</a>. For API specifications, see <a href="#api-flow">API Flow</a>.</p>
<h2 id="system-architecture">System Architecture</h2>
<p>waQup is built as a cloud-native, microservices-oriented platform optimized for voice-first interactions, real-time conversation, and audio generation/streaming. The system prioritizes low-latency voice interactions, reliable audio delivery, and scalable ritual generation.</p>
<h2 id="high-level-architecture-diagram">High-Level Architecture Diagram</h2>
<div class="mermaid-container"><div class="mermaid">graph TB
    subgraph "Client Layer"
        Mobile[Mobile App<br/>iOS/Android<br/>React Native]
        Web[Web App<br/>Progressive Web App<br/>React]
    end
    
    subgraph "API Gateway"
        Gateway[API Gateway<br/>Auth, Rate Limiting, Routing<br/>JWT Authentication]
    end
    
    subgraph "Core Services"
        Conversation[Conversation Service<br/>State Machine, Dialogue Management<br/>WebSocket + REST]
        ContentGen[Content Generation Service<br/>LLM Integration, Personalization<br/>Affirmations, Meditations, Rituals<br/>Node.js/Python]
        AudioGen[Audio Generation Service<br/>TTS Integration, Audio Synthesis<br/>Async Processing]
        RitualLib[Ritual Library Service<br/>Storage, Retrieval, Playback<br/>REST API]
        UserSvc[User Service<br/>Profiles, Preferences, History<br/>REST API]
        CreditSvc[Credit Management Service<br/>Balance Tracking, Consumption, Refunds<br/>REST API]
    end
    
    subgraph "Marketplace Services"
        CreatorSvc[Creator Service<br/>Profiles, Publishing, Analytics<br/>REST API]
        CatalogSvc[Catalog Service<br/>Discovery, Search, Recommendations<br/>REST API]
        PaymentSvc[Payment Service<br/>Subscriptions, Purchases, Billing<br/>Stripe Integration]
        RewardSvc[Reward Service<br/>Token Distribution, Value Tracking<br/>REST API<br/>See Value & Growth Economy]
    end
    
    subgraph "Data Layer"
        UserDB[(User Database<br/>PostgreSQL<br/>Profiles, Preferences)]
        RitualDB[(Ritual Database<br/>PostgreSQL<br/>Rituals, Packs, Metadata)]
        AudioStore[(Audio Storage<br/>S3/Cloud Storage<br/>MP3/OGG Files)]
        Cache[(Cache Layer<br/>Redis<br/>Sessions, Frequent Data)]
        SearchIdx[(Search Index<br/>Elasticsearch<br/>Ritual Discovery)]
    end
    
    subgraph "External Services"
        LLM[LLM Provider<br/>OpenAI GPT-4<br/>Anthropic Claude]
        TTS[TTS Provider<br/>ElevenLabs<br/>PlayHT]
        PaymentGateway[Payment Gateway<br/>Stripe<br/>Subscriptions & Payments]
        CDN[CDN<br/>CloudFront/Cloudflare<br/>Audio Delivery]
    end
    
    Mobile --> Gateway
    Web --> Gateway
    Gateway --> Conversation
    Gateway --> RitualLib
    Gateway --> CatalogSvc
    Gateway --> PaymentSvc
    Gateway --> CreditSvc
    
    Conversation --> ContentGen
    Conversation --> UserSvc
    Conversation --> CreditSvc
    ContentGen --> LLM
    ContentGen --> UserSvc
    ContentGen --> RitualDB
    ContentGen --> CreditSvc
    
    AudioGen --> TTS
    AudioGen --> AudioStore
    ContentGen --> AudioGen
    
    RitualLib --> RitualDB
    RitualLib --> AudioStore
    RitualLib --> Cache
    RitualLib --> CDN
    
    UserSvc --> UserDB
    UserSvc --> Cache
    
    CreatorSvc --> UserDB
    CatalogSvc --> RitualDB
    CatalogSvc --> SearchIdx
    CatalogSvc --> Cache
    
    PaymentSvc --> PaymentGateway
    PaymentSvc --> UserDB
    PaymentSvc --> CreditSvc
    
    CreditSvc --> UserDB
    CreditSvc --> Cache
    
    RewardSvc --> UserDB
    RewardSvc --> Cache</div></div>
<h2 id="technology-stack">Technology Stack</h2>
<h3 id="backend">Backend</h3>
<ul>
<li><strong>Runtime</strong>: Node.js (TypeScript) or Python (FastAPI)</li>
<li><strong>API Framework</strong>: Express.js / FastAPI</li>
<li><strong>API Protocol</strong>: REST + WebSocket (for real-time conversation)</li>
<li><strong>Database</strong>: PostgreSQL (primary data store)</li>
<li><strong>Cache</strong>: Redis (session state, frequently accessed data)</li>
<li><strong>Search</strong>: Elasticsearch (ritual discovery, full-text search)</li>
<li><strong>Message Queue</strong>: RabbitMQ / AWS SQS (async job processing)</li>
<li><strong>Object Storage</strong>: AWS S3 / Google Cloud Storage (audio files)</li>
</ul>
<h3 id="frontend">Frontend</h3>
<ul>
<li><strong>Mobile</strong>: React Native (iOS/Android)</li>
<li><strong>Web</strong>: React (Progressive Web App)</li>
<li><strong>State Management</strong>: Zustand / Redux Toolkit</li>
<li><strong>Audio Playback</strong>: Web Audio API / React Native Audio</li>
<li><strong>Real-time</strong>: WebSocket client</li>
</ul>
<h3 id="infrastructure">Infrastructure</h3>
<ul>
<li><strong>Hosting</strong>: AWS / Google Cloud Platform</li>
<li><strong>Containerization</strong>: Docker</li>
<li><strong>Orchestration</strong>: Kubernetes / ECS</li>
<li><strong>CI/CD</strong>: GitHub Actions / GitLab CI</li>
<li><strong>Monitoring</strong>: Datadog / New Relic / Prometheus + Grafana</li>
<li><strong>Logging</strong>: ELK Stack / CloudWatch</li>
<li><strong>CDN</strong>: CloudFront / Cloudflare (audio delivery)</li>
</ul>
<h2 id="core-services-architecture">Core Services Architecture</h2>
<h3 id="conversation-service">Conversation Service</h3>
<p>Manages the state machine for ritual creation and return loops. Handles dialogue flow, context management, and user intent extraction.</p>
<strong>Key Responsibilities</strong>:
<ul>
<li>Maintain conversation state per user session</li>
<li>Route user inputs to appropriate handlers</li>
<li>Extract intent and context from natural language</li>
<li>Coordinate with Ritual Generation Service</li>
<li>Manage ephemeral vs. persistent conversation data</li>
</ul>
<h3 id="content-generation-service">Content Generation Service</h3>
<p>Generates personalized content (affirmations, guided meditations, rituals) using LLM based on user conversation and context.</p>
<strong>Key Responsibilities</strong>:
<ul>
<li>Validate credit availability before generation (via Credit Management Service)</li>
<li>Adapt generation logic based on content type (affirmation, meditation, ritual)</li>
<li>Call LLM with user intent, conversation history, and content type</li>
<li>Apply type-specific structure (affirmations: statements, meditations: state induction, rituals: identity encoding)</li>
<li>Apply personalization rules based on user profile and history</li>
<li>Structure content according to waQup format (type-specific)</li>
<li>Trigger audio generation after text generation</li>
<li>Consume credit on successful completion (cost varies by type)</li>
<li>Store generated content in database (with content_type)</li>
<li>Request credit refund on generation failure</li>
</ul>
<h3 id="audio-generation-service">Audio Generation Service</h3>
<p>Converts ritual text to audio using TTS, applies voice characteristics, and stores audio files.</p>
<strong>Key Responsibilities</strong>:
<ul>
<li>Call TTS API with ritual text and voice selection</li>
<li>Apply voice characteristics (pace, tone, pauses)</li>
<li>Store generated audio in object storage</li>
<li>Generate audio metadata (duration, format, quality)</li>
<li>Handle audio format conversion and optimization</li>
</ul>
<h3 id="ritual-library-service">Ritual Library Service</h3>
<p>Manages user's saved rituals, playback, and ritual history.</p>
<strong>Key Responsibilities</strong>:
<ul>
<li>Store and retrieve user's ritual library</li>
<li>Track playback history and practice frequency</li>
<li>Provide audio streaming URLs</li>
<li>Handle ritual sharing and export</li>
<li>Manage ritual organization (tags, folders)</li>
<li>Free unlimited replay (no credit consumption)</li>
</ul>
<h3 id="credit-management-service">Credit Management Service</h3>
<p>Manages user credit balances, consumption, and refunds.</p>
<strong>Key Responsibilities</strong>:
<ul>
<li>Track credit balance per user</li>
<li>Validate credit availability before consumption</li>
<li>Process credit consumption on successful ritual creation</li>
<li>Handle credit refunds on system errors</li>
<li>Record credit transaction history</li>
<li>Integrate with Payment Service for credit purchases</li>
<li>Provide credit balance API endpoints</li>
</ul>
<h2 id="data-flow">Data Flow</h2>
<p>waQup's data flow architecture ensures efficient, secure, and scalable handling of user data, ritual generation, audio processing, and marketplace transactions. Data flows through multiple layers: client, API gateway, services, data stores, and external integrations.</p>
<h2 id="ritual-creation-data-flow">Ritual Creation Data Flow</h2>
<div class="mermaid-container"><div class="mermaid">flowchart LR
    Start([User Initiates<br/>Ritual Creation]) --> WS[WebSocket<br/>Conversation Service]
    WS --> Intent[Extract Intent<br/>Redis Session]
    Intent --> Context[Gather Context<br/>Redis Session]
    Context --> Details[Practice Details<br/>Redis Session]
    Details --> Personalize[Personalization<br/>Query Preferences]
    Personalize --> Confirm[Present Summary<br/>User Confirms]
    Confirm --> CheckCredit[Check Credit Balance<br/>Credit Service]
    CheckCredit --> Generate[Generate Text<br/>Call LLM API]
    Generate --> LLM[LLM Provider<br/>OpenAI/Anthropic]
    LLM --> Text[Ritual Text]
    Text --> StoreText[Store Text<br/>PostgreSQL]
    StoreText --> AudioGen[Audio Generation<br/>Async Queue]
    AudioGen --> TTS[TTS Provider<br/>ElevenLabs/PlayHT]
    TTS --> Audio[Audio File]
    Audio --> S3[Store Audio<br/>S3/Cloud Storage]
    S3 --> CDN[CDN<br/>Distribution]
    CDN --> Complete[Ritual Complete<br/>Available]
    Complete --> ConsumeCredit[Consume Credit<br/>Credit Service]
    ConsumeCredit --> Persist[Persist History<br/>PostgreSQL]
    
    style Start fill:#e1f5ff
    style Complete fill:#d4edda
    style S3 fill:#fff3cd
    style StoreText fill:#f8d7da
    style Persist fill:#f8d7da</div></div>
<h2 id="audio-playback-data-flow">Audio Playback Data Flow</h2>
<div class="mermaid-container"><div class="mermaid">flowchart LR
    User([User Selects<br/>Ritual]) --> Library[Ritual Library Service]
    Library --> CheckCache{Check Redis<br/>Cache}
    CheckCache -->|Hit| Cache[Return Cached<br/>Audio URL]
    CheckCache -->|Miss| DB[Query PostgreSQL<br/>for Ritual Metadata]
    DB --> AudioURL[Get Audio URL<br/>from Metadata]
    AudioURL --> S3[S3/Cloud Storage<br/>Generate Pre-signed URL]
    S3 --> CDN[CDN Delivery<br/>CloudFront/Cloudflare]
    CDN --> Play[Audio Playback<br/>to User]
    Play --> Event[Record Practice Event<br/>Store in PostgreSQL]
    Cache --> Play
    
    style User fill:#e1f5ff
    style Play fill:#d4edda
    style S3 fill:#fff3cd</div></div>
<h2 id="marketplace-purchase-data-flow">Marketplace Purchase Data Flow</h2>
<div class="mermaid-container"><div class="mermaid">sequenceDiagram
    participant User
    participant Catalog Service
    participant Payment Service
    participant Stripe
    participant User DB
    participant Ritual Library
    participant Reward Service

    User->>Catalog Service: Browse & Select Pack
    Catalog Service->>User: Display Pack Details
    User->>Payment Service: Initiate Purchase
    Payment Service->>Stripe: Create Payment Intent
    Stripe-->>Payment Service: Payment Intent Created
    Payment Service->>User: Redirect to Stripe Checkout
    User->>Stripe: Complete Payment
    Stripe->>Payment Service: Webhook (Payment Success)
    Payment Service->>User DB: Record Purchase Transaction
    Payment Service->>Ritual Library: Grant Pack Access
    Ritual Library->>User: Pack Available
    Payment Service->>Reward Service: Calculate Creator Rewards
    Reward Service->>User DB: Update Creator Token Balance
    Note over Reward Service: Token mechanics detailed in Value & Growth Economy document</div></div>
<h2 id="data-storage-architecture">Data Storage Architecture</h2>
<h3 id="persistent-storage-postgresql">Persistent Storage (PostgreSQL)</h3>
<strong>Users Table</strong>:
<pre><code>- id (UUID, primary key)
<ul>
<li>email (string, unique)</li>
<li>created_at (timestamp)</li>
<li>preferences (JSONB: voice, pace, tone preferences)</li>
<li>practice_history_summary (JSONB: total practices, last practice)</li>
<li>credit_balance (integer, default: 1 for free tier)</code></pre></li>
</ul>
<strong>Credit Transactions Table</strong>:
<pre><code>- id (UUID, primary key)
<ul>
<li>user_id (UUID, foreign key)</li>
<li>transaction_type (enum: purchase, consumption, refund)</li>
<li>amount (integer, credits)</li>
<li>balance_after (integer)</li>
<li>content_item_id (UUID, nullable, foreign key) -- replaces ritual_id</li>
<li>content_type (enum: affirmation, guided_meditation, ritual, nullable)</li>
<li>created_at (timestamp)</li>
<li>metadata (JSONB: purchase_pack_id, refund_reason, etc.)</code></pre></li>
</ul>
<strong>Content Items Table</strong> (replaces Rituals Table):
<pre><code>- id (UUID, primary key)
<ul>
<li>user_id (UUID, foreign key)</li>
<li>content_type (enum: affirmation, guided_meditation, ritual) NOT NULL</li>
<li>title (string)</li>
<li>content_text (text)</li>
<li>voice_id (UUID, foreign key)</li>
<li>audio_url (string, S3 URL)</li>
<li>audio_duration (integer, seconds)</li>
<li>depth (string: shallow, medium, deep) -- system-assigned</li>
<li>tags (TEXT[] array)</li>
<li>structure (JSONB: type-specific structure)</li>
<li>context (JSONB: creation context, personalization)</li>
<li>created_at (timestamp)</li>
<li>last_played_at (timestamp)</li>
<li>play_count (integer, for reference only)</li>
<li>metadata (JSONB: additional metadata)</code></pre></li>
</ul>
<strong>Note</strong>: See Content Types & Taxonomy document for detailed schema and type definitions.
<strong>Ritual Packs Table</strong>:
<pre><code>- id (UUID, primary key)
<ul>
<li>creator_id (UUID, foreign key)</li>
<li>title (string)</li>
<li>description (text)</li>
<li>price_type (enum: free, one_time, subscription)</li>
<li>price_amount (decimal)</li>
<li>subscription_interval (enum: monthly, annual)</li>
<li>published_at (timestamp)</li>
<li>status (enum: draft, published, archived)</code></pre></li>
</ul>
<strong>Conversations Table</strong>:
<pre><code>- id (UUID, primary key)
<ul>
<li>user_id (UUID, foreign key)</li>
<li>session_id (string)</li>
<li>messages (JSONB: array of messages)</li>
<li>state (JSONB: state machine state)</li>
<li>created_at (timestamp)</li>
<li>completed_at (timestamp)</li>
<li>resulting_ritual_id (UUID, nullable)</code></pre></li>
</ul>
<strong>Practice Events Table</strong>:
<pre><code>- id (UUID, primary key)
<ul>
<li>user_id (UUID, foreign key)</li>
<li>ritual_id (UUID, foreign key)</li>
<li>started_at (timestamp)</li>
<li>completed_at (timestamp, nullable)</li>
<li>duration (integer, seconds)</li>
<li>metadata (JSONB: context, device)</code></pre></li>
</ul>
<h3 id="ephemeral-storage-redis">Ephemeral Storage (Redis)</h3>
<strong>Session State</strong>:
<pre><code>Key: session:{session_id}
<p>Value: {</p>
<p>state: "IntentDiscovery" | "ContextGathering" | ...</p>
<p>context: { intent, time, location, ... }</p>
<p>user_id: UUID</p>
<p>}</p>
<p>TTL: 1 hour</code></pre>
<strong>User Profile Cache</strong>:
<pre><code>Key: user:{user_id}:profile
<p>Value: { preferences, voice_selection, ... }</p>
<p>TTL: 15 minutes</code></pre>
<strong>Ritual Metadata Cache</strong>:
<pre><code>Key: ritual:{ritual_id}:metadata
<p>Value: { title, duration, audio_url, ... }</p>
<p>TTL: 1 hour</code></pre>
<strong>Search Results Cache</strong>:
<pre><code>Key: search:{query_hash}
<p>Value: [pack_ids, ...]</p>
<p>TTL: 5 minutes</code></pre>
<h3 id="object-storage-s3cloud-storage">Object Storage (S3/Cloud Storage)</h3>
<strong>Audio Files</strong>:
<pre><code>Path: audio/{user_id}/{ritual_id}/{version}.mp3
<p>Format: MP3 or OGG</p>
<p>Retention: Permanent (until user deletion)</p>
<p>CDN: CloudFront/Cloudflare for delivery</code></pre>
<h2 id="data-flow-patterns">Data Flow Patterns</h2>
<h3 id="write-pattern-ritual-creation">Write Pattern (Ritual Creation)</h3>
<ol>
<li><strong>Ephemeral Data</strong> (Redis):</li>
</ol>
<ul>
<li>Conversation state stored in Redis during creation</li>
<li>Fast access for state machine transitions</li>
<li>TTL: 1 hour (session timeout)</li>
</ul>
<ol>
<li><strong>Persistent Data</strong> (PostgreSQL):</li>
</ol>
<ul>
<li>Ritual metadata written after generation</li>
<li>Conversation history persisted for personalization</li>
<li>Practice events recorded after completion</li>
</ul>
<ol>
<li><strong>Object Storage</strong> (S3):</li>
</ol>
<ul>
<li>Audio files stored asynchronously</li>
<li>Pre-signed URLs generated for secure access</li>
<li>CDN distribution for fast delivery</li>
</ul>
<h3 id="read-pattern-ritual-playback">Read Pattern (Ritual Playback)</h3>
<ol>
<li><strong>Cache First</strong> (Redis):</li>
</ol>
<ul>
<li>Check cache for ritual metadata</li>
<li>Check cache for audio URLs</li>
<li>Cache hit: Return immediately</li>
</ul>
<ol>
<li><strong>Database Fallback</strong> (PostgreSQL):</li>
</ol>
<ul>
<li>Cache miss: Query database</li>
<li>Retrieve ritual metadata</li>
<li>Generate pre-signed S3 URL</li>
</ul>
<ol>
<li><strong>CDN Delivery</strong> (CloudFront/Cloudflare):</li>
</ol>
<ul>
<li>Audio served via CDN</li>
<li>Low latency, global distribution</li>
<li>Reduced origin server load</li>
</ul>
<h3 id="search-pattern-marketplace-discovery">Search Pattern (Marketplace Discovery)</h3>
<ol>
<li><strong>Cache Check</strong> (Redis):</li>
</ol>
<ul>
<li>Check cached search results</li>
<li>Return if cache hit (< 5 minutes)</li>
</ul>
<ol>
<li><strong>Search Index</strong> (Elasticsearch):</li>
</ol>
<ul>
<li>Query Elasticsearch for pack matches</li>
<li>Full-text search, filtering, sorting</li>
<li>Return pack IDs</li>
</ul>
<ol>
<li><strong>Database Lookup</strong> (PostgreSQL):</li>
</ol>
<ul>
<li>Fetch full pack metadata</li>
<li>Include creator information</li>
<li>Return complete results</li>
</ul>
<h2 id="data-privacy-security">Data Privacy & Security</h2>
<h3 id="data-minimization">Data Minimization</h3>
<ul>
<li>Collect only necessary data</li>
<li>No biometric data without consent</li>
<li>No location data without consent</li>
<li>No social connections (not a social platform)</li>
</ul>
<h3 id="data-encryption">Data Encryption</h3>
<ul>
<li>TLS in transit (all API calls)</li>
<li>Encryption at rest (sensitive data)</li>
<li>Pre-signed URLs for audio (time-limited access)</li>
<li>JWT tokens for authentication</li>
</ul>
<h3 id="data-access-control">Data Access Control</h3>
<ul>
<li>User data isolated by user_id</li>
<li>Creator data isolated by creator_id</li>
<li>Role-based access control (RBAC)</li>
<li>Audit logging for sensitive operations</li>
</ul>
<h3 id="data-export-deletion">Data Export & Deletion</h3>
<ul>
<li>Users can export all data (JSON format)</li>
<li>Users can delete account and all data</li>
<li>Audio files deleted from S3</li>
<li>Database records soft-deleted or purged</li>
<li>GDPR compliance</li>
</ul>
<strong>Note</strong>: For comprehensive security architecture details, see Architecture Overview document. For ethical data handling principles, see AI Voice & Ethics document.
<h2 id="data-flow-performance">Data Flow Performance</h2>
<h3 id="optimization-strategies">Optimization Strategies</h3>
<ol>
<li><strong>Caching</strong>:</li>
</ol>
<ul>
<li>Aggressive caching of frequently accessed data</li>
<li>Redis for hot data (sessions, profiles, metadata)</li>
<li>CDN for static assets (audio files)</li>
</ul>
<ol>
<li><strong>Async Processing</strong>:</li>
</ol>
<ul>
<li>Audio generation via message queue</li>
<li>LLM calls can be async for non-real-time flows</li>
<li>Background jobs for analytics and reporting</li>
</ul>
<ol>
<li><strong>Database Optimization</strong>:</li>
</ol>
<ul>
<li>Indexed queries (user_id, ritual_id, creator_id)</li>
<li>Read replicas for read-heavy workloads</li>
<li>Connection pooling</li>
<li>Query optimization</li>
</ul>
<ol>
<li><strong>CDN Distribution</strong>:</li>
</ol>
<ul>
<li>All audio delivery via CDN</li>
<li>Global edge locations</li>
<li>Reduced latency for users worldwide</li>
</ul>
<h2 id="data-flow-monitoring">Data Flow Monitoring</h2>
<h3 id="key-metrics">Key Metrics</h3>
<ul>
<li><strong>Latency</strong>: API response times, audio generation time</li>
<li><strong>Throughput</strong>: Requests per second, rituals generated per hour</li>
<li><strong>Cache Hit Rate</strong>: Redis cache effectiveness</li>
<li><strong>Error Rate</strong>: Failed requests, generation failures</li>
<li><strong>Storage</strong>: Database size, S3 storage usage</li>
</ul>
<h3 id="alerting">Alerting</h3>
<ul>
<li>High latency (> 1s for API calls)</li>
<li>High error rate (> 1% failures)</li>
<li>Cache hit rate drop (< 80%)</li>
<li>Storage capacity warnings (> 80% full)</li>
<li>Service downtime</li>
</ul>
<h2 id="api-flow">API Flow</h2>
<p>waQup uses a RESTful API architecture with WebSocket support for real-time conversation flows. All APIs are versioned, authenticated via JWT, and follow consistent patterns for error handling, rate limiting, and response formatting.</p>
<h2 id="api-gateway-flow">API Gateway Flow</h2>
<div class="mermaid-container"><div class="mermaid">sequenceDiagram
    participant Client
    participant API Gateway
    participant Auth Service
    participant Rate Limiter
    participant Service
    participant Database

    Client->>API Gateway: API Request + JWT Token
    API Gateway->>Auth Service: Validate Token
    Auth Service-->>API Gateway: Token Valid/Invalid
    alt Token Invalid
        API Gateway-->>Client: 401 Unauthorized
    else Token Valid
        API Gateway->>Rate Limiter: Check Rate Limit
        Rate Limiter-->>API Gateway: Limit OK/Exceeded
        alt Rate Limit Exceeded
            API Gateway-->>Client: 429 Too Many Requests
        else Rate Limit OK
            API Gateway->>Service: Route Request
            Service->>Database: Query/Update Data
            Database-->>Service: Return Data
            Service-->>API Gateway: Response
            API Gateway-->>Client: JSON Response
        end
    end</div></div>
<h2 id="core-api-endpoints">Core API Endpoints</h2>
<h3 id="authentication-apis">Authentication APIs</h3>
<strong>POST /api/v1/auth/register</strong>
<pre><code>Request:
<p>{</p>
<p>"email": "user@example.com",</p>
<p>"password": "securepassword"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"token": "jwt_token_here",</p>
<p>"refresh_token": "refresh_token_here",</p>
<p>"user": {</p>
<p>"id": "uuid",</p>
<p>"email": "user@example.com"</p>
<p>}</p>
<p>}</code></pre>
<strong>POST /api/v1/auth/login</strong>
<pre><code>Request:
<p>{</p>
<p>"email": "user@example.com",</p>
<p>"password": "securepassword"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"token": "jwt_token_here",</p>
<p>"refresh_token": "refresh_token_here",</p>
<p>"user": {</p>
<p>"id": "uuid",</p>
<p>"email": "user@example.com"</p>
<p>}</p>
<p>}</code></pre>
<strong>POST /api/v1/auth/refresh</strong>
<pre><code>Request:
<p>{</p>
<p>"refresh_token": "refresh_token_here"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"token": "new_jwt_token_here"</p>
<p>}</code></pre>
<h3 id="conversation-apis">Conversation APIs</h3>
<strong>WebSocket: /ws/conversation</strong>
<pre><code>// Connect
<p>ws://api.waqup.com/ws/conversation?token=jwt_token</p>
<p>// Send message</p>
<p>{</p>
<p>"type": "message",</p>
<p>"content": "I need something to help me sleep",</p>
<p>"session_id": "session_uuid"</p>
<p>}</p>
<p>// Receive response</p>
<p>{</p>
<p>"type": "response",</p>
<p>"content": "I'd be happy to help you create a ritual for sleep...",</p>
<p>"state": "IntentDiscovery",</p>
<p>"session_id": "session_uuid"</p>
<p>}</code></pre>
<strong>POST /api/v1/conversation/start</strong>
<pre><code>Request:
<p>{</p>
<p>"content_type": "affirmation" | "guided_meditation" | "ritual",</p>
<p>"intent": "sleep" // optional, can be discovered through conversation</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"session_id": "uuid",</p>
<p>"content_type": "ritual",</p>
<p>"state": "Greeting",</p>
<p>"message": "Hello! I'd be happy to help you create a personalized ritual..."</p>
<p>}</code></pre>
<strong>POST /api/v1/conversation/message</strong>
<pre><code>Request:
<p>{</p>
<p>"session_id": "uuid",</p>
<p>"message": "I want something calming for evening"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"session_id": "uuid",</p>
<p>"state": "ContextGathering",</p>
<p>"response": "That sounds wonderful. When would you like to practice this?",</p>
<p>"context": {</p>
<p>"intent": "calming",</p>
<p>"time_preference": null</p>
<p>}</p>
<p>}</code></pre>
<strong>GET /api/v1/conversation/state</strong>
<pre><code>Response:
<p>{</p>
<p>"session_id": "uuid",</p>
<p>"state": "PracticeDetails",</p>
<p>"context": {</p>
<p>"intent": "calming",</p>
<p>"time_preference": "evening",</p>
<p>"duration": "10 minutes"</p>
<p>},</p>
<p>"messages": [...]</p>
<p>}</code></pre>
<strong>POST /api/v1/conversation/complete</strong>
<pre><code>Request:
<p>{</p>
<p>"session_id": "uuid",</p>
<p>"confirm": true</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"ritual_id": "uuid",</p>
<p>"status": "generating",</p>
<p>"estimated_time": 30 // seconds</p>
<p>}</code></pre>
<h3 id="content-apis-affirmations-guided-meditations-rituals">Content APIs (Affirmations, Guided Meditations, Rituals)</h3>
<strong>GET /api/v1/content</strong>
<pre><code>Query Parameters:
<ul>
<li>content_type: "affirmation" | "guided_meditation" | "ritual" | null (all)</li>
<li>page: number (default: 1)</li>
<li>limit: number (default: 20)</li>
<li>tags: string[] (optional)</li>
<li>depth: "shallow" | "medium" | "deep" | null (all)</li>
</ul>
<p>Response:</p>
<p>{</p>
<p>"content_items": [</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"content_type": "ritual",</p>
<p>"title": "Evening Calm",</p>
<p>"depth": "deep",</p>
<p>"duration": 600,</p>
<p>"tags": ["evening", "calming"],</p>
<p>"created_at": "2024-01-01T00:00:00Z",</p>
<p>"last_played_at": "2024-01-15T10:30:00Z",</p>
<p>"play_count": 12</p>
<p>}</p>
<p>],</p>
<p>"pagination": {</p>
<p>"page": 1,</p>
<p>"limit": 20,</p>
<p>"total": 45,</p>
<p>"pages": 3</p>
<p>}</p>
<p>}</code></pre>
<strong>GET /api/v1/content/{id}</strong>
<pre><code>Response:
<p>{</p>
<p>"id": "uuid",</p>
<p>"content_type": "ritual",</p>
<p>"title": "Evening Calm",</p>
<p>"content_text": "Find a comfortable position...",</p>
<p>"depth": "deep",</p>
<p>"duration": 600,</p>
<p>"tags": ["calming", "evening", "breath"],</p>
<p>"voice": {</p>
<p>"id": "uuid",</p>
<p>"name": "Calm Guide"</p>
<p>},</p>
<p>"audio_url": "https://cdn.waqup.com/audio/...",</p>
<p>"created_at": "2024-01-01T00:00:00Z",</p>
<p>"structure": {...},</p>
<p>"context": {...}</p>
<p>}</code></pre>
<strong>POST /api/v1/content/{id}/play</strong>
<pre><code>Request:
<p>{</p>
<p>"started_at": "2024-01-15T10:30:00Z"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"practice_event_id": "uuid",</p>
<p>"status": "started"</p>
<p>}</code></pre>
<strong>POST /api/v1/content/{id}/complete</strong>
<pre><code>Request:
<p>{</p>
<p>"practice_event_id": "uuid",</p>
<p>"completed_at": "2024-01-15T10:40:00Z",</p>
<p>"duration": 600</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"practice_event_id": "uuid",</p>
<p>"status": "completed"</p>
<p>}</code></pre>
<strong>DELETE /api/v1/content/{id}</strong>
<pre><code>Response:
<p>{</p>
<p>"status": "deleted",</p>
<p>"content_item_id": "uuid"</p>
<p>}</code></pre>
<strong>GET /api/v1/content/{id}/export</strong>
<pre><code>Query Parameters:
<ul>
<li>format: "text" | "audio" | "both"</li>
</ul>
<p>Response:</p>
<p>{</p>
<p>"text": "Find a comfortable position...",</p>
<p>"audio_url": "https://cdn.waqup.com/audio/...",</p>
<p>"exported_at": "2024-01-15T10:45:00Z"</p>
<p>}</code></pre>
<h3 id="marketplace-apis">Marketplace APIs</h3>
<strong>GET /api/v1/catalog/packs</strong>
<pre><code>Query Parameters:
<ul>
<li>page: number</li>
<li>limit: number</li>
<li>search: string</li>
<li>tags: string[]</li>
<li>creator_id: uuid</li>
<li>price_type: "free" | "one_time" | "subscription"</li>
</ul>
<p>Response:</p>
<p>{</p>
<p>"packs": [</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"title": "Morning Energy Pack",</p>
<p>"description": "Start your day with intention...",</p>
<p>"creator": {</p>
<p>"id": "uuid",</p>
<p>"name": "Sarah Facilitator"</p>
<p>},</p>
<p>"price_type": "subscription",</p>
<p>"price_amount": 9.99,</p>
<p>"subscription_interval": "monthly",</p>
<p>"ritual_count": 5,</p>
<p>"rating": 4.8,</p>
<p>"review_count": 127</p>
<p>}</p>
<p>],</p>
<p>"pagination": {...}</p>
<p>}</code></pre>
<strong>GET /api/v1/catalog/packs/{id}</strong>
<pre><code>Response:
<p>{</p>
<p>"id": "uuid",</p>
<p>"title": "Morning Energy Pack",</p>
<p>"description": "Start your day with intention...",</p>
<p>"creator": {...},</p>
<p>"rituals": [</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"title": "Sunrise Breath",</p>
<p>"duration": 300,</p>
<p>"practice_type": "breath_work"</p>
<p>}</p>
<p>],</p>
<p>"price_type": "subscription",</p>
<p>"price_amount": 9.99,</p>
<p>"user_has_access": false</p>
<p>}</code></pre>
<strong>GET /api/v1/catalog/recommendations</strong>
<pre><code>Response:
<p>{</p>
<p>"recommendations": [</p>
<p>{</p>
<p>"pack_id": "uuid",</p>
<p>"reason": "Based on your practice history",</p>
<p>"score": 0.85</p>
<p>}</p>
<p>]</p>
<p>}</code></pre>
<strong>POST /api/v1/payments/checkout</strong>
<pre><code>Request:
<p>{</p>
<p>"pack_id": "uuid",</p>
<p>"price_type": "subscription",</p>
<p>"success_url": "https://app.waqup.com/success",</p>
<p>"cancel_url": "https://app.waqup.com/cancel"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"checkout_url": "https://checkout.stripe.com/...",</p>
<p>"session_id": "stripe_session_id"</p>
<p>}</code></pre>
<strong>POST /api/v1/payments/webhook</strong>
<pre><code>// Stripe webhook handler (internal)
<p>Request:</p>
<p>{</p>
<p>"type": "checkout.session.completed",</p>
<p>"data": {</p>
<p>"object": {</p>
<p>"id": "stripe_session_id",</p>
<p>"metadata": {</p>
<p>"pack_id": "uuid",</p>
<p>"user_id": "uuid"</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</code></pre>
<h3 id="user-apis">User APIs</h3>
<strong>GET /api/v1/users/me</strong>
<pre><code>Response:
<p>{</p>
<p>"id": "uuid",</p>
<p>"email": "user@example.com",</p>
<p>"preferences": {</p>
<p>"voice_id": "uuid",</p>
<p>"pace": "moderate",</p>
<p>"tone": "warm"</p>
<p>},</p>
<p>"created_at": "2024-01-01T00:00:00Z"</p>
<p>}</code></pre>
<strong>PUT /api/v1/users/me</strong>
<pre><code>Request:
<p>{</p>
<p>"preferences": {</p>
<p>"voice_id": "new_voice_id",</p>
<p>"pace": "slower"</p>
<p>}</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"preferences": {</p>
<p>"voice_id": "new_voice_id",</p>
<p>"pace": "slower",</p>
<p>"tone": "warm"</p>
<p>}</p>
<p>}</code></pre>
<strong>GET /api/v1/users/me/history</strong>
<pre><code>Query Parameters:
<ul>
<li>page: number</li>
<li>limit: number</li>
<li>ritual_id: uuid (optional)</li>
</ul>
<p>Response:</p>
<p>{</p>
<p>"practice_events": [</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"ritual_id": "uuid",</p>
<p>"ritual_title": "Evening Calm",</p>
<p>"started_at": "2024-01-15T10:30:00Z",</p>
<p>"completed_at": "2024-01-15T10:40:00Z",</p>
<p>"duration": 600</p>
<p>}</p>
<p>],</p>
<p>"pagination": {...}</p>
<p>}</code></pre>
<h3 id="credit-apis">Credit APIs</h3>
<strong>GET /api/v1/credits/balance</strong>
<pre><code>Response:
<p>{</p>
<p>"balance": 5,</p>
<p>"free_tier_used": true,</p>
<p>"last_transaction_at": "2024-01-15T10:30:00Z"</p>
<p>}</code></pre>
<strong>GET /api/v1/credits/transactions</strong>
<pre><code>Query Parameters:
<ul>
<li>page: number</li>
<li>limit: number</li>
<li>transaction_type: "purchase" | "consumption" | "refund" (optional)</li>
</ul>
<p>Response:</p>
<p>{</p>
<p>"transactions": [</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"type": "consumption",</p>
<p>"amount": -1,</p>
<p>"balance_after": 4,</p>
<p>"ritual_id": "uuid",</p>
<p>"created_at": "2024-01-15T10:30:00Z"</p>
<p>},</p>
<p>{</p>
<p>"id": "uuid",</p>
<p>"type": "purchase",</p>
<p>"amount": 10,</p>
<p>"balance_after": 11,</p>
<p>"pack_id": "seeker",</p>
<p>"created_at": "2024-01-10T08:00:00Z"</p>
<p>}</p>
<p>],</p>
<p>"pagination": {...}</p>
<p>}</code></pre>
<strong>POST /api/v1/credits/purchase</strong>
<pre><code>Request:
<p>{</p>
<p>"pack_type": "starter" | "seeker" | "architect",</p>
<p>"success_url": "https://app.waqup.com/success",</p>
<p>"cancel_url": "https://app.waqup.com/cancel"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"checkout_url": "https://checkout.stripe.com/...",</p>
<p>"session_id": "stripe_session_id",</p>
<p>"credits_amount": 3</p>
<p>}</code></pre>
<strong>POST /api/v1/credits/check</strong>
<pre><code>Request:
<p>{</p>
<p>"action": "ritual_creation",</p>
<p>"ritual_id": "uuid" // optional, for modifications</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>"sufficient": true,</p>
<p>"balance": 5,</p>
<p>"required": 1,</p>
<p>"message": "You have sufficient credits"</p>
<p>}</code></pre>
<h2 id="api-flow-diagrams">API Flow Diagrams</h2>
<h3 id="ritual-creation-flow">Ritual Creation Flow</h3>
<div class="mermaid-container"><div class="mermaid">sequenceDiagram
    participant Client
    participant API Gateway
    participant Conversation Service
    participant Ritual Gen Service
    participant LLM
    participant Audio Gen Service
    participant TTS
    participant Database

    Client->>API Gateway: POST /conversation/start (with content_type)
    API Gateway->>Conversation Service: Create session
    Conversation Service->>Database: Store session state + content_type
    Conversation Service-->>Client: Session ID + Greeting (type-specific)

    Client->>API Gateway: POST /conversation/message
    API Gateway->>Conversation Service: Process message
    Conversation Service->>Database: Update session state
    Conversation Service-->>Client: Response + Next question

    Note over Client,Conversation Service: Repeat until ritual confirmed

    Client->>API Gateway: POST /conversation/complete
    API Gateway->>Conversation Service: Finalize ritual
    Conversation Service->>Credit Service: Check credit balance
    Credit Service-->>Conversation Service: Credit available
    Conversation Service->>Ritual Gen Service: Generate ritual
    Ritual Gen Service->>LLM: Generate text
    LLM-->>Ritual Gen Service: Ritual text
    Ritual Gen Service->>Database: Store ritual text
    Ritual Gen Service->>Audio Gen Service: Generate audio
    Audio Gen Service->>TTS: Synthesize voice
    TTS-->>Audio Gen Service: Audio file
    Audio Gen Service->>Database: Store audio URL
    Audio Gen Service->>Credit Service: Consume credit (on success)
    Credit Service-->>Audio Gen Service: Credit consumed
    Audio Gen Service-->>Ritual Gen Service: Audio ready
    Ritual Gen Service-->>Conversation Service: Ritual complete
    Conversation Service-->>Client: Ritual ID + Status</div></div>
<h3 id="ritual-playback-flow">Ritual Playback Flow</h3>
<div class="mermaid-container"><div class="mermaid">sequenceDiagram
    participant Client
    participant API Gateway
    participant Ritual Library Service
    participant Cache
    participant Database
    participant CDN

    Client->>API Gateway: GET /content/{id}
    API Gateway->>Ritual Library Service: Get content item
    Ritual Library Service->>Cache: Check cache
    alt Cache Hit
        Cache-->>Ritual Library Service: Cached data
    else Cache Miss
        Ritual Library Service->>Database: Query ritual
        Database-->>Ritual Library Service: Ritual data
        Ritual Library Service->>Cache: Store in cache
    end
    Ritual Library Service->>CDN: Generate pre-signed URL
    CDN-->>Ritual Library Service: Audio URL
    Ritual Library Service-->>Client: Ritual + Audio URL

    Client->>API Gateway: POST /content/{id}/play
    API Gateway->>Ritual Library Service: Record play event
    Ritual Library Service->>Database: Store practice event (with content_type)
    Ritual Library Service-->>Client: Practice started

    Client->>CDN: Stream audio
    CDN-->>Client: Audio stream

    Client->>API Gateway: POST /content/{id}/complete
    API Gateway->>Ritual Library Service: Complete practice
    Ritual Library Service->>Database: Update practice event
    Ritual Library Service-->>Client: Practice completed</div></div>
<h3 id="marketplace-purchase-flow">Marketplace Purchase Flow</h3>
<div class="mermaid-container"><div class="mermaid">sequenceDiagram
    participant Client
    participant API Gateway
    participant Catalog Service
    participant Payment Service
    participant Stripe
    participant Database
    participant Ritual Library Service

    Client->>API Gateway: GET /catalog/packs/{id}
    API Gateway->>Catalog Service: Get pack details
    Catalog Service->>Database: Query pack
    Database-->>Catalog Service: Pack data
    Catalog Service-->>Client: Pack details

    Client->>API Gateway: POST /payments/checkout
    API Gateway->>Payment Service: Create checkout
    Payment Service->>Stripe: Create checkout session
    Stripe-->>Payment Service: Checkout URL
    Payment Service-->>Client: Redirect to Stripe

    Client->>Stripe: Complete payment
    Stripe->>Payment Service: Webhook (payment success)
    Payment Service->>Database: Record purchase
    Payment Service->>Ritual Library Service: Grant access
    Ritual Library Service->>Database: Link pack to user
    Payment Service-->>Stripe: Webhook acknowledged

    Client->>API Gateway: GET /catalog/packs/{id}
    API Gateway->>Catalog Service: Get pack
    Catalog Service->>Database: Query pack + access
    Database-->>Catalog Service: Pack + user_has_access: true
    Catalog Service-->>Client: Pack with access granted</div></div>
<h2 id="api-design-principles">API Design Principles</h2>
<h3 id="restful-design">RESTful Design</h3>
<ul>
<li>Standard HTTP methods (GET, POST, PUT, DELETE)</li>
<li>Resource-based URLs (<code>/rituals/{id}</code>)</li>
<li>Consistent response formats</li>
<li>Proper HTTP status codes</li>
</ul>
<h3 id="versioning">Versioning</h3>
<ul>
<li>URL-based versioning (<code>/api/v1/...</code>)</li>
<li>Backward compatibility maintained</li>
<li>Deprecation notices for old versions</li>
</ul>
<h3 id="authentication">Authentication</h3>
<ul>
<li>JWT tokens for stateless auth</li>
<li>Refresh token rotation</li>
<li>Token expiration (15 minutes access, 7 days refresh)</li>
</ul>
<h3 id="rate-limiting">Rate Limiting</h3>
<ul>
<li>Per-user rate limits</li>
<li>Tiered limits (free vs. paid users)</li>
<li>429 status code with retry-after header</li>
</ul>
<h3 id="error-handling">Error Handling</h3>
<pre><code>{
<p>"error": {</p>
<p>"code": "RITUAL_NOT_FOUND",</p>
<p>"message": "Ritual with ID {id} not found",</p>
<p>"details": {...}</p>
<p>}</p>
<p>}</code></pre>
<h3 id="pagination">Pagination</h3>
<pre><code>{
<p>"data": [...],</p>
<p>"pagination": {</p>
<p>"page": 1,</p>
<p>"limit": 20,</p>
<p>"total": 100,</p>
<p>"pages": 5,</p>
<p>"has_next": true,</p>
<p>"has_prev": false</p>
<p>}</p>
<p>}</code></pre>
<h2 id="api-performance">API Performance</h2>
<h3 id="caching-strategy">Caching Strategy</h3>
<ul>
<li>Redis cache for frequently accessed data</li>
<li>Cache TTL: 15 minutes (user profiles), 1 hour (ritual metadata)</li>
<li>CDN cache for audio files (long TTL)</li>
</ul>
<h3 id="async-processing">Async Processing</h3>
<ul>
<li>Audio generation via message queue</li>
<li>LLM calls can be async for non-real-time flows</li>
<li>Webhook processing async</li>
</ul>
<h3 id="response-times">Response Times</h3>
<ul>
<li>API responses: < 200ms (p95)</li>
<li>Audio generation: < 30s (async)</li>
<li>Ritual generation: < 10s (LLM call)</li>
</ul>
<h2 id="api-security">API Security</h2>
<h3 id="input-validation">Input Validation</h3>
<ul>
<li>Schema validation for all requests</li>
<li>SQL injection prevention</li>
<li>XSS prevention</li>
<li>Rate limiting</li>
</ul>
<h3 id="data-protection">Data Protection</h3>
<ul>
<li>No sensitive data in URLs</li>
<li>Pre-signed URLs for audio (time-limited)</li>
<li>Encryption at rest and in transit</li>
<li>GDPR compliance</li>
</ul>
<h3 id="monitoring">Monitoring</h3>
<ul>
<li>Request logging (structured JSON)</li>
<li>Error tracking</li>
<li>Performance monitoring</li>
<li>Security event logging</li>
</ul>
<h2 id="data-architecture">Data Architecture</h2>
<h3 id="primary-databases">Primary Databases</h3>
<strong>PostgreSQL</strong>:
<ul>
<li>User profiles and preferences</li>
<li>Ritual metadata and text</li>
<li>Ritual packs and creator data</li>
<li>Practice history</li>
<li>Conversation history</li>
<li>Payment and subscription data</li>
<li>Credit balances and transactions</li>
<li>Reward transactions</li>
</ul>
<strong>Redis</strong>:
<ul>
<li>Session state (conversation state machine)</li>
<li>User profiles cache</li>
<li>Ritual metadata cache</li>
<li>Search results cache</li>
<li>Audio URLs cache</li>
</ul>
<strong>Elasticsearch</strong>:
<ul>
<li>Ritual pack search index</li>
<li>Full-text search capabilities</li>
<li>Discovery and recommendation data</li>
</ul>
<strong>S3/Cloud Storage</strong>:
<ul>
<li>Generated audio files (MP3/OGG)</li>
<li>Organized by user_id/ritual_id</li>
<li>Served via CDN for fast delivery</li>
</ul>
<h2 id="security-architecture">Security Architecture</h2>
<ul>
<li><strong>Authentication</strong>: JWT tokens, refresh token rotation</li>
<li><strong>Authorization</strong>: Role-based access control (user, creator, admin)</li>
<li><strong>Data Encryption</strong>: TLS in transit, encryption at rest for sensitive data</li>
<li><strong>API Security</strong>: Rate limiting, input validation, SQL injection prevention</li>
<li><strong>Audio Security</strong>: Pre-signed URLs with expiration, access control</li>
<li><strong>Payment Security</strong>: PCI compliance via Stripe, no card data storage</li>
<li><strong>Privacy</strong>: Data minimization, user consent for tracking, GDPR compliance</li>
</ul>
<strong>Note</strong>: For detailed data flow security patterns, see Data Flow document. For ethical privacy principles, see AI Voice & Ethics document.
<h2 id="scalability-strategy">Scalability Strategy</h2>
<h3 id="initial-scale-year-1">Initial Scale (Year 1)</h3>
<ul>
<li><strong>Users</strong>: 10,000 active users</li>
<li><strong>Rituals</strong>: 100,000 generated rituals</li>
<li><strong>Daily Practices</strong>: 5,000 practice sessions</li>
<li><strong>Audio Storage</strong>: 1 TB</li>
<li><strong>API Requests</strong>: 100,000 requests/day</li>
</ul>
<h3 id="growth-scale-year-2-3">Growth Scale (Year 2-3)</h3>
<ul>
<li><strong>Users</strong>: 100,000 active users</li>
<li><strong>Rituals</strong>: 1,000,000 generated rituals</li>
<li><strong>Daily Practices</strong>: 50,000 practice sessions</li>
<li><strong>Audio Storage</strong>: 10 TB</li>
<li><strong>API Requests</strong>: 1,000,000 requests/day</li>
</ul>
<h3 id="scaling-approach">Scaling Approach</h3>
<ul>
<li><strong>Horizontal Scaling</strong>: Stateless services scale horizontally</li>
<li><strong>Database Scaling</strong>: Read replicas for read-heavy workloads, connection pooling</li>
<li><strong>Caching</strong>: Aggressive caching to reduce database load</li>
<li><strong>CDN</strong>: All audio delivery via CDN</li>
<li><strong>Async Processing</strong>: Audio generation and LLM calls via message queue</li>
<li><strong>Cost Optimization</strong>: Reserved instances, spot instances for batch jobs</li>
</ul>
<h2 id="deployment-architecture">Deployment Architecture</h2>
<ul>
<li><strong>Environments</strong>: Development, Staging, Production</li>
<li><strong>Containerization</strong>: Docker containers for all services</li>
<li><strong>Orchestration</strong>: Kubernetes for production, Docker Compose for local dev</li>
<li><strong>CI/CD</strong>: Automated testing, building, and deployment</li>
<li><strong>Blue-Green Deployment</strong>: Zero-downtime deployments</li>
<li><strong>Database Migrations</strong>: Versioned migrations, rollback capability</li>
<li><strong>Feature Flags</strong>: Gradual feature rollouts, A/B testing support</li>
</ul>
<h2 id="observability">Observability</h2>
<h3 id="logging">Logging</h3>
<ul>
<li><strong>Structured Logging</strong>: JSON format with correlation IDs</li>
<li><strong>Log Levels</strong>: ERROR, WARN, INFO, DEBUG</li>
<li><strong>Sensitive Data</strong>: Never log passwords, tokens, or payment data</li>
<li><strong>Log Aggregation</strong>: Centralized logging via ELK Stack or CloudWatch</li>
</ul>
<h3 id="monitoring">Monitoring</h3>
<ul>
<li><strong>Metrics</strong>: Request latency, error rates, audio generation time, LLM call latency</li>
<li><strong>Alerts</strong>: Error rate spikes, latency degradation, service downtime</li>
<li><strong>Dashboards</strong>: Service health, user activity, marketplace metrics</li>
</ul>
<h3 id="tracing">Tracing</h3>
<ul>
<li><strong>Distributed Tracing</strong>: Request tracing across services (Jaeger/Zipkin)</li>
<li><strong>Correlation IDs</strong>: Track requests through entire system</li>
</ul>
            </div>
            </div>
        </main>
    </div>
</body>
</html>